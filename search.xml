<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>(转)服务端高并发分布式架构演进之路</title>
    <url>/2019/11/11/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文以淘宝作为例子，介绍从一百个并发到千万级并发情况下服务端的架构的演进过程，同时列举出每个演进阶段会遇到的相关技术，让大家对架构的演进有一个整体的认知，文章最后汇总了一些架构设计的原则。</p>
<h1 id="2-基本概念"><a href="#2-基本概念" class="headerlink" title="2. 基本概念"></a>2. 基本概念</h1><p>在介绍架构之前，为了避免部分读者对架构设计中的一些概念不了解，下面对几个最基础的概念进行介绍：</p>
<ul>
<li><strong>分布式</strong><br>系统中的多个模块在不同服务器上部署，即可称为分布式系统，如Tomcat和数据库分别部署在不同的服务器上，或两个相同功能的Tomcat分别部署在不同服务器上</li>
<li><strong>高可用</strong><br>系统中部分节点失效时，其他节点能够接替它继续提供服务，则可认为系统具有高可用性</li>
<li><strong>集群</strong><br>一个特定领域的软件部署在多台服务器上并作为一个整体提供一类服务，这个整体称为集群。如Zookeeper中的Master和Slave分别部署在多台服务器上，共同组成一个整体提供集中配置服务。在常见的集群中，客户端往往能够连接任意一个节点获得服务，并且当集群中一个节点掉线时，其他节点往往能够自动的接替它继续提供服务，这时候说明集群具有高可用性</li>
<li><strong>负载均衡</strong><br>请求发送到系统时，通过某些方式把请求均匀分发到多个节点上，使系统中每个节点能够均匀的处理请求负载，则可认为系统是负载均衡的</li>
<li><strong>正向代理和反向代理</strong><br>系统内部要访问外部网络时，统一通过一个代理服务器把请求转发出去，在外部网络看来就是代理服务器发起的访问，此时代理服务器实现的是正向代理；当外部请求进入系统时，代理服务器把该请求转发到系统中的某台服务器上，对外部请求来说，与之交互的只有代理服务器，此时代理服务器实现的是反向代理。简单来说，正向代理是代理服务器代替系统内部来访问外部网络的过程，反向代理是外部请求访问系统时通过代理服务器转发到内部服务器的过程。</li>
</ul>
<h1 id="3-架构演进"><a href="#3-架构演进" class="headerlink" title="3. 架构演进"></a>3. 架构演进</h1><h2 id="单机架构"><a href="#单机架构" class="headerlink" title="单机架构"></a>单机架构</h2><p><img src="https://segmentfault.com/img/bVbqHnQ?w=579&h=210" alt="clipboard.png"></p>
<p>以淘宝作为例子。在网站最初时，应用数量与用户数都较少，可以把Tomcat和数据库部署在同一台服务器上。浏览器往<a href="http://www.taobao.com发起请求时，首先经过DNS服务器（域名系统）把域名转换为实际IP地址10.102.4.1，浏览器转而访问该IP对应的Tomcat。" target="_blank" rel="noopener">www.taobao.com发起请求时，首先经过DNS服务器（域名系统）把域名转换为实际IP地址10.102.4.1，浏览器转而访问该IP对应的Tomcat。</a></p>
<blockquote>
<p><strong>随着用户数的增长，Tomcat和数据库之间竞争资源，单机性能不足以支撑业务</strong></p>
</blockquote>
<h2 id="第一次演进：Tomcat与数据库分开部署"><a href="#第一次演进：Tomcat与数据库分开部署" class="headerlink" title="第一次演进：Tomcat与数据库分开部署"></a>第一次演进：Tomcat与数据库分开部署</h2><p><img src="https://segmentfault.com/img/bVbqHnF?w=581&h=207" alt="clipboard.png"></p>
<p>Tomcat和数据库分别独占服务器资源，显著提高两者各自性能。</p>
<blockquote>
<p><strong>随着用户数的增长，并发读写数据库成为瓶颈</strong></p>
</blockquote>
<h2 id="第二次演进：引入本地缓存和分布式缓存"><a href="#第二次演进：引入本地缓存和分布式缓存" class="headerlink" title="第二次演进：引入本地缓存和分布式缓存"></a>第二次演进：引入本地缓存和分布式缓存</h2><p><img src="https://segmentfault.com/img/bVbqHo5?w=581&h=321" alt="clipboard.png"></p>
<p>在Tomcat同服务器上或同JVM中增加本地缓存，并在外部增加分布式缓存，缓存热门商品信息或热门商品的html页面等。通过缓存能把绝大多数请求在读写数据库前拦截掉，大大降低数据库压力。其中涉及的技术包括：使用memcached作为本地缓存，使用Redis作为分布式缓存，还会涉及缓存一致性、缓存穿透/击穿、缓存雪崩、热点数据集中失效等问题。</p>
<blockquote>
<p><strong>缓存抗住了大部分的访问请求，随着用户数的增长，并发压力主要落在单机的Tomcat上，响应逐渐变慢</strong></p>
</blockquote>
<h2 id="第三次演进：引入反向代理实现负载均衡"><a href="#第三次演进：引入反向代理实现负载均衡" class="headerlink" title="第三次演进：引入反向代理实现负载均衡"></a>第三次演进：引入反向代理实现负载均衡</h2><p><img src="https://segmentfault.com/img/bVbqjM7?w=401&h=330" alt="clipboard.png"></p>
<p>在多台服务器上分别部署Tomcat，使用反向代理软件（Nginx）把请求均匀分发到每个Tomcat中。此处假设Tomcat最多支持100个并发，Nginx最多支持50000个并发，那么理论上Nginx把请求分发到500个Tomcat上，就能抗住50000个并发。其中涉及的技术包括：Nginx、HAProxy，两者都是工作在网络第七层的反向代理软件，主要支持http协议，还会涉及session共享、文件上传下载的问题。</p>
<blockquote>
<p><strong>反向代理使应用服务器可支持的并发量大大增加，但并发量的增长也意味着更多请求穿透到数据库，单机的数据库最终成为瓶颈</strong></p>
</blockquote>
<h2 id="第四次演进：数据库读写分离"><a href="#第四次演进：数据库读写分离" class="headerlink" title="第四次演进：数据库读写分离"></a>第四次演进：数据库读写分离</h2><p><img src="https://segmentfault.com/img/bVbqjPI?w=427&h=293" alt="clipboard.png"></p>
<p>把数据库划分为读库和写库，读库可以有多个，通过同步机制把写库的数据同步到读库，对于需要查询最新写入数据场景，可通过在缓存中多写一份，通过缓存获得最新数据。其中涉及的技术包括：Mycat，它是数据库中间件，可通过它来组织数据库的分离读写和分库分表，客户端通过它来访问下层数据库，还会涉及数据同步，数据一致性的问题。</p>
<blockquote>
<p><strong>业务逐渐变多，不同业务之间的访问量差距较大，不同业务直接竞争数据库，相互影响性能</strong></p>
</blockquote>
<h2 id="第五次演进：数据库按业务分库"><a href="#第五次演进：数据库按业务分库" class="headerlink" title="第五次演进：数据库按业务分库"></a>第五次演进：数据库按业务分库</h2><p><img src="https://segmentfault.com/img/bVbqknA?w=537&h=442" alt="clipboard.png"></p>
<p>把不同业务的数据保存到不同的数据库中，使业务之间的资源竞争降低，对于访问量大的业务，可以部署更多的服务器来支撑。这样同时导致跨业务的表无法直接做关联分析，需要通过其他途径来解决，但这不是本文讨论的重点，有兴趣的可以自行搜索解决方案。</p>
<blockquote>
<p><strong>随着用户数的增长，单机的写库会逐渐会达到性能瓶颈</strong></p>
</blockquote>
<h2 id="第六次演进：把大表拆分为小表"><a href="#第六次演进：把大表拆分为小表" class="headerlink" title="第六次演进：把大表拆分为小表"></a>第六次演进：把大表拆分为小表</h2><p><img src="https://segmentfault.com/img/bVbqjUO?w=584&h=442" alt="clipboard.png"></p>
<p>比如针对评论数据，可按照商品ID进行hash，路由到对应的表中存储；针对支付记录，可按照小时创建表，每个小时表继续拆分为小表，使用用户ID或记录编号来路由数据。只要实时操作的表数据量足够小，请求能够足够均匀的分发到多台服务器上的小表，那数据库就能通过水平扩展的方式来提高性能。其中前面提到的Mycat也支持在大表拆分为小表情况下的访问控制。</p>
<p>这种做法显著的增加了数据库运维的难度，对DBA的要求较高。数据库设计到这种结构时，已经可以称为分布式数据库，但是这只是一个逻辑的数据库整体，数据库里不同的组成部分是由不同的组件单独来实现的，如分库分表的管理和请求分发，由Mycat实现，SQL的解析由单机的数据库实现，读写分离可能由网关和消息队列来实现，查询结果的汇总可能由数据库接口层来实现等等，这种架构其实是MPP（大规模并行处理）架构的一类实现。</p>
<p>目前开源和商用都已经有不少MPP数据库，开源中比较流行的有Greenplum、TiDB、Postgresql XC、HAWQ等，商用的如南大通用的GBase、睿帆科技的雪球DB、华为的LibrA等等，不同的MPP数据库的侧重点也不一样，如TiDB更侧重于分布式OLTP场景，Greenplum更侧重于分布式OLAP场景，这些MPP数据库基本都提供了类似Postgresql、Oracle、MySQL那样的SQL标准支持能力，能把一个查询解析为分布式的执行计划分发到每台机器上并行执行，最终由数据库本身汇总数据进行返回，也提供了诸如权限管理、分库分表、事务、数据副本等能力，并且大多能够支持100个节点以上的集群，大大降低了数据库运维的成本，并且使数据库也能够实现水平扩展。</p>
<blockquote>
<p><strong>数据库和Tomcat都能够水平扩展，可支撑的并发大幅提高，随着用户数的增长，最终单机的Nginx会成为瓶颈</strong></p>
</blockquote>
<h2 id="第七次演进：使用LVS或F5来使多个Nginx负载均衡"><a href="#第七次演进：使用LVS或F5来使多个Nginx负载均衡" class="headerlink" title="第七次演进：使用LVS或F5来使多个Nginx负载均衡"></a>第七次演进：使用LVS或F5来使多个Nginx负载均衡</h2><p><img src="https://segmentfault.com/img/bVbqkrJ?w=589&h=515" alt="clipboard.png"></p>
<p>由于瓶颈在Nginx，因此无法通过两层的Nginx来实现多个Nginx的负载均衡。图中的LVS和F5是工作在网络第四层的负载均衡解决方案，其中LVS是软件，运行在操作系统内核态，可对TCP请求或更高层级的网络协议进行转发，因此支持的协议更丰富，并且性能也远高于Nginx，可假设单机的LVS可支持几十万个并发的请求转发；F5是一种负载均衡硬件，与LVS提供的能力类似，性能比LVS更高，但价格昂贵。由于LVS是单机版的软件，若LVS所在服务器宕机则会导致整个后端系统都无法访问，因此需要有备用节点。可使用keepalived软件模拟出虚拟IP，然后把虚拟IP绑定到多台LVS服务器上，浏览器访问虚拟IP时，会被路由器重定向到真实的LVS服务器，当主LVS服务器宕机时，keepalived软件会自动更新路由器中的路由表，把虚拟IP重定向到另外一台正常的LVS服务器，从而达到LVS服务器高可用的效果。</p>
<p>此处需要注意的是，上图中从Nginx层到Tomcat层这样画并不代表全部Nginx都转发请求到全部的Tomcat，在实际使用时，可能会是几个Nginx下面接一部分的Tomcat，这些Nginx之间通过keepalived实现高可用，其他的Nginx接另外的Tomcat，这样可接入的Tomcat数量就能成倍的增加。</p>
<blockquote>
<p><strong>由于LVS也是单机的，随着并发数增长到几十万时，LVS服务器最终会达到瓶颈，此时用户数达到千万甚至上亿级别，用户分布在不同的地区，与服务器机房距离不同，导致了访问的延迟会明显不同</strong></p>
</blockquote>
<h2 id="第八次演进：通过DNS轮询实现机房间的负载均衡"><a href="#第八次演进：通过DNS轮询实现机房间的负载均衡" class="headerlink" title="第八次演进：通过DNS轮询实现机房间的负载均衡"></a>第八次演进：通过DNS轮询实现机房间的负载均衡</h2><p><img src="https://segmentfault.com/img/bVbqkuH?w=752&h=535" alt="clipboard.png"></p>
<p>在DNS服务器中可配置一个域名对应多个IP地址，每个IP地址对应到不同的机房里的虚拟IP。当用户访问<a href="http://www.taobao.com时，DNS服务器会使用轮询策略或其他策略，来选择某个IP供用户访问。此方式能实现机房间的负载均衡，至此，系统可做到机房级别的水平扩展，千万级到亿级的并发量都可通过增加机房来解决，系统入口处的请求并发量不再是问题。" target="_blank" rel="noopener">www.taobao.com时，DNS服务器会使用轮询策略或其他策略，来选择某个IP供用户访问。此方式能实现机房间的负载均衡，至此，系统可做到机房级别的水平扩展，千万级到亿级的并发量都可通过增加机房来解决，系统入口处的请求并发量不再是问题。</a></p>
<blockquote>
<p><strong>随着数据的丰富程度和业务的发展，检索、分析等需求越来越丰富，单单依靠数据库无法解决如此丰富的需求</strong></p>
</blockquote>
<h2 id="第九次演进：引入NoSQL数据库和搜索引擎等技术"><a href="#第九次演进：引入NoSQL数据库和搜索引擎等技术" class="headerlink" title="第九次演进：引入NoSQL数据库和搜索引擎等技术"></a>第九次演进：引入NoSQL数据库和搜索引擎等技术</h2><p><img src="https://segmentfault.com/img/bVbqHtd?w=685&h=443" alt="clipboard.png"></p>
<p>当数据库中的数据多到一定规模时，数据库就不适用于复杂的查询了，往往只能满足普通查询的场景。对于统计报表场景，在数据量大时不一定能跑出结果，而且在跑复杂查询时会导致其他查询变慢，对于全文检索、可变数据结构等场景，数据库天生不适用。因此需要针对特定的场景，引入合适的解决方案。如对于海量文件存储，可通过分布式文件系统HDFS解决，对于key value类型的数据，可通过HBase和Redis等方案解决，对于全文检索场景，可通过搜索引擎如ElasticSearch解决，对于多维分析场景，可通过Kylin或Druid等方案解决。</p>
<p>当然，引入更多组件同时会提高系统的复杂度，不同的组件保存的数据需要同步，需要考虑一致性的问题，需要有更多的运维手段来管理这些组件等。</p>
<blockquote>
<p><strong>引入更多组件解决了丰富的需求，业务维度能够极大扩充，随之而来的是一个应用中包含了太多的业务代码，业务的升级迭代变得困难</strong></p>
</blockquote>
<h2 id="第十次演进：大应用拆分为小应用"><a href="#第十次演进：大应用拆分为小应用" class="headerlink" title="第十次演进：大应用拆分为小应用"></a>第十次演进：大应用拆分为小应用</h2><p><img src="https://segmentfault.com/img/bVbqHzB?w=687&h=455" alt="clipboard.png"></p>
<p>按照业务板块来划分应用代码，使单个应用的职责更清晰，相互之间可以做到独立升级迭代。这时候应用之间可能会涉及到一些公共配置，可以通过分布式配置中心Zookeeper来解决。</p>
<blockquote>
<p><strong>不同应用之间存在共用的模块，由应用单独管理会导致相同代码存在多份，导致公共功能升级时全部应用代码都要跟着升级</strong></p>
</blockquote>
<h2 id="第十一次演进：复用的功能抽离成微服务"><a href="#第十一次演进：复用的功能抽离成微服务" class="headerlink" title="第十一次演进：复用的功能抽离成微服务"></a>第十一次演进：复用的功能抽离成微服务</h2><p><img src="https://segmentfault.com/img/bVbqHAs?w=682&h=536" alt="clipboard.png"></p>
<p>如用户管理、订单、支付、鉴权等功能在多个应用中都存在，那么可以把这些功能的代码单独抽取出来形成一个单独的服务来管理，这样的服务就是所谓的微服务，应用和服务之间通过HTTP、TCP或RPC请求等多种方式来访问公共服务，每个单独的服务都可以由单独的团队来管理。此外，可以通过Dubbo、SpringCloud等框架实现服务治理、限流、熔断、降级等功能，提高服务的稳定性和可用性。</p>
<blockquote>
<p><strong>不同服务的接口访问方式不同，应用代码需要适配多种访问方式才能使用服务，此外，应用访问服务，服务之间也可能相互访问，调用链将会变得非常复杂，逻辑变得混乱</strong></p>
</blockquote>
<h2 id="第十二次演进：引入企业服务总线ESB屏蔽服务接口的访问差异"><a href="#第十二次演进：引入企业服务总线ESB屏蔽服务接口的访问差异" class="headerlink" title="第十二次演进：引入企业服务总线ESB屏蔽服务接口的访问差异"></a>第十二次演进：引入企业服务总线ESB屏蔽服务接口的访问差异</h2><p><img src="https://segmentfault.com/img/bVbqHBi?w=693&h=593" alt="clipboard.png"></p>
<p>通过ESB统一进行访问协议转换，应用统一通过ESB来访问后端服务，服务与服务之间也通过ESB来相互调用，以此降低系统的耦合程度。这种单个应用拆分为多个应用，公共服务单独抽取出来来管理，并使用企业消息总线来解除服务之间耦合问题的架构，就是所谓的SOA（面向服务）架构，这种架构与微服务架构容易混淆，因为表现形式十分相似。个人理解，微服务架构更多是指把系统里的公共服务抽取出来单独运维管理的思想，而SOA架构则是指一种拆分服务并使服务接口访问变得统一的架构思想，SOA架构中包含了微服务的思想。</p>
<blockquote>
<p><strong>业务不断发展，应用和服务都会不断变多，应用和服务的部署变得复杂，同一台服务器上部署多个服务还要解决运行环境冲突的问题，此外，对于如大促这类需要动态扩缩容的场景，需要水平扩展服务的性能，就需要在新增的服务上准备运行环境，部署服务等，运维将变得十分困难</strong></p>
</blockquote>
<h2 id="第十三次演进：引入容器化技术实现运行环境隔离与动态服务管理"><a href="#第十三次演进：引入容器化技术实现运行环境隔离与动态服务管理" class="headerlink" title="第十三次演进：引入容器化技术实现运行环境隔离与动态服务管理"></a>第十三次演进：引入容器化技术实现运行环境隔离与动态服务管理</h2><p><img src="https://segmentfault.com/img/bVbqHBG?w=645&h=614" alt="clipboard.png"></p>
<p>目前最流行的容器化技术是Docker，最流行的容器管理服务是Kubernetes(K8S)，应用/服务可以打包为Docker镜像，通过K8S来动态分发和部署镜像。Docker镜像可理解为一个能运行你的应用/服务的最小的操作系统，里面放着应用/服务的运行代码，运行环境根据实际的需要设置好。把整个“操作系统”打包为一个镜像后，就可以分发到需要部署相关服务的机器上，直接启动Docker镜像就可以把服务起起来，使服务的部署和运维变得简单。</p>
<p>在大促的之前，可以在现有的机器集群上划分出服务器来启动Docker镜像，增强服务的性能，大促过后就可以关闭镜像，对机器上的其他服务不造成影响（在3.14节之前，服务运行在新增机器上需要修改系统配置来适配服务，这会导致机器上其他服务需要的运行环境被破坏）。</p>
<blockquote>
<p><strong>使用容器化技术后服务动态扩缩容问题得以解决，但是机器还是需要公司自身来管理，在非大促的时候，还是需要闲置着大量的机器资源来应对大促，机器自身成本和运维成本都极高，资源利用率低</strong></p>
</blockquote>
<h2 id="第十四次演进：以云平台承载系统"><a href="#第十四次演进：以云平台承载系统" class="headerlink" title="第十四次演进：以云平台承载系统"></a>第十四次演进：以云平台承载系统</h2><p><img src="https://segmentfault.com/img/bVbqHDy?w=977&h=583" alt="clipboard.png"></p>
<p>系统可部署到公有云上，利用公有云的海量机器资源，解决动态硬件资源的问题，在大促的时间段里，在云平台中临时申请更多的资源，结合Docker和K8S来快速部署服务，在大促结束后释放资源，真正做到按需付费，资源利用率大大提高，同时大大降低了运维成本。</p>
<p>所谓的云平台，就是把海量机器资源，通过统一的资源管理，抽象为一个资源整体，在之上可按需动态申请硬件资源（如CPU、内存、网络等），并且之上提供通用的操作系统，提供常用的技术组件（如Hadoop技术栈，MPP数据库等）供用户使用，甚至提供开发好的应用，用户不需要关系应用内部使用了什么技术，就能够解决需求（如音视频转码服务、邮件服务、个人博客等）。在云平台中会涉及如下几个概念：</p>
<ul>
<li><strong>IaaS：</strong>基础设施即服务。对应于上面所说的机器资源统一为资源整体，可动态申请硬件资源的层面；</li>
<li><strong>PaaS：</strong>平台即服务。对应于上面所说的提供常用的技术组件方便系统的开发和维护；</li>
<li><strong>SaaS：</strong>软件即服务。对应于上面所说的提供开发好的应用或服务，按功能或性能要求付费。</li>
</ul>
<blockquote>
<p><strong>至此，以上所提到的从高并发访问问题，到服务的架构和系统实施的层面都有了各自的解决方案，但同时也应该意识到，在上面的介绍中，其实是有意忽略了诸如跨机房数据同步、分布式事务实现等等的实际问题，这些问题以后有机会再拿出来单独讨论</strong></p>
</blockquote>
<h1 id="4-架构设计总结"><a href="#4-架构设计总结" class="headerlink" title="4. 架构设计总结"></a>4. 架构设计总结</h1><ul>
<li><strong>架构的调整是否必须按照上述演变路径进行？</strong><br>不是的，以上所说的架构演变顺序只是针对某个侧面进行单独的改进，在实际场景中，可能同一时间会有几个问题需要解决，或者可能先达到瓶颈的是另外的方面，这时候就应该按照实际问题实际解决。如在政府类的并发量可能不大，但业务可能很丰富的场景，高并发就不是重点解决的问题，此时优先需要的可能会是丰富需求的解决方案。</li>
<li><strong>对于将要实施的系统，架构应该设计到什么程度？</strong><br>对于单次实施并且性能指标明确的系统，架构设计到能够支持系统的性能指标要求就足够了，但要留有扩展架构的接口以便不备之需。对于不断发展的系统，如电商平台，应设计到能满足下一阶段用户量和性能指标要求的程度，并根据业务的增长不断的迭代升级架构，以支持更高的并发和更丰富的业务。</li>
<li><strong>服务端架构和大数据架构有什么区别？</strong><br>所谓的“大数据”其实是海量数据采集清洗转换、数据存储、数据分析、数据服务等场景解决方案的一个统称，在每一个场景都包含了多种可选的技术，如数据采集有Flume、Sqoop、Kettle等，数据存储有分布式文件系统HDFS、FastDFS，NoSQL数据库HBase、MongoDB等，数据分析有Spark技术栈、机器学习算法等。总的来说大数据架构就是根据业务的需求，整合各种大数据组件组合而成的架构，一般会提供分布式存储、分布式计算、多维分析、数据仓库、机器学习算法等能力。而服务端架构更多指的是应用组织层面的架构，底层能力往往是由大数据架构来提供。</li>
<li><strong>有没有一些架构设计的原则？</strong><ul>
<li>N+1设计。系统中的每个组件都应做到没有单点故障；</li>
<li>回滚设计。确保系统可以向前兼容，在系统升级时应能有办法回滚版本；</li>
<li>禁用设计。应该提供控制具体功能是否可用的配置，在系统出现故障时能够快速下线功能；</li>
<li>监控设计。在设计阶段就要考虑监控的手段；</li>
<li>多活数据中心设计。若系统需要极高的高可用，应考虑在多地实施数据中心进行多活，至少在一个机房断电的情况下系统依然可用；</li>
<li>采用成熟的技术。刚开发的或开源的技术往往存在很多隐藏的bug，出了问题没有商业支持可能会是一个灾难；</li>
<li>资源隔离设计。应避免单一业务占用全部资源；</li>
<li>架构应能水平扩展。系统只有做到能水平扩展，才能有效避免瓶颈问题；</li>
<li>非核心则购买。非核心功能若需要占用大量的研发资源才能解决，则考虑购买成熟的产品；</li>
<li>使用商用硬件。商用硬件能有效降低硬件故障的机率；</li>
<li>快速迭代。系统应该快速开发小功能模块，尽快上线进行验证，早日发现问题大大降低系统交付的风险；</li>
<li>无状态设计。服务接口应该做成无状态的，当前接口的访问不依赖于接口上次访问的状态。</li>
</ul>
</li>
</ul>
<h4 id="作者：huashiou"><a href="#作者：huashiou" class="headerlink" title="作者：huashiou"></a>作者：huashiou</h4><h4 id="原文链接：https-segmentfault-com-a-1190000018626163-articleHeader2"><a href="#原文链接：https-segmentfault-com-a-1190000018626163-articleHeader2" class="headerlink" title="原文链接：https://segmentfault.com/a/1190000018626163#articleHeader2"></a>原文链接：<a href="https://segmentfault.com/a/1190000018626163#articleHeader2" target="_blank" rel="noopener">https://segmentfault.com/a/1190000018626163#articleHeader2</a></h4>]]></content>
  </entry>
  <entry>
    <title>PostgreSQL</title>
    <url>/2019/11/03/PostgreSQL/</url>
    <content><![CDATA[<h1 id="PostgreSQL"><a href="#PostgreSQL" class="headerlink" title="PostgreSQL"></a>PostgreSQL</h1><blockquote>
<p>PostgreSQL 不寻常的名字导致一些读者停下来尝试拼读它，特别是那些把SQL拼读为”sequel”的人（当然也有人读作“circle”）。PostgreSQL 开发者把它拼读为 “post-gress-Q-L”。它也经常被简略念为 “postgres”。</p>
<p>PostgreSQL是一个功能强大的开源<strong>对象-关系</strong>数据库系统，经过30多年的积极开发，在可靠性，功能稳健性和性能方面赢得了良好的声誉。</p>
<p>PostgreSQL是<strong>跨平台</strong>的，可以在许多操作系统上运行，如Linux，FreeBSD，OS X，Solaris和Microsoft Windows等。</p>
</blockquote>
<h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><p>PostgreSQL由计算机科学教授Michael Stonebraker在UCB创建。 它最初叫做Postgres。 1986年由Michael Stonebraker教授作为后续项目和Ingres项目启动，克服了当代数据库系统的问题。PostgreSQL现在是任何地方都很先进的开源数据库。</p>
<h2 id="什么是对象数据库"><a href="#什么是对象数据库" class="headerlink" title="什么是对象数据库"></a>什么是对象数据库</h2><ul>
<li>面向对象数据库系统(OODBS)支持定义和操作OODB，应满足两个标准：首先它是<strong>数据库系统</strong>，其次它也是<strong>面向对象系统</strong>。第一个标准即作为数据库系统应具备的能力(持久性、事务管理、并发控制、恢复、查询、版本管理、完整性、安全性)。第二个标准就是要求面向对象数据库充分支持完整的面向对象(OO)概念和控制机制。</li>
<li>在纯对象式数据库中，资料以<strong>对象的形式</strong>存储，这些对象只能由其所属的类中定义的方法来操作。</li>
<li>它强调高级程序设计语言与数据库的无缝连接。什么是无缝连接，就是你可以编写<strong>不同编程语言</strong>的代码，而<strong>无需重新编译</strong>数据库。<em>eg:你用C语言编了一个程序，你可以不需要（或基本不需要）任何改动就将它作用于数据库，即你可以用C语言透明访问数据库，就好像数据库根本不存在一样。</em>所以也有人把面向对象数据库理解为语言的持久化。</li>
</ul>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>1.易维护、质量高、高扩展：因为采用了面向对象的思想，使得系统满足高内聚、低耦合的特性，因此在维护、复用、扩展等方面显得非常方便</p>
<p>2.效率高：在软件开发时，可以根据设计的需要对现实世界的事物进行抽象，产生类。</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>1.标准化：在面向对象数据模型的其它方面，如&amp;体系结构、编程接口语言上的理解尚未达到一致。</p>
<p>2.模式修改：由于模型较为复杂（而且缺乏数学基础），使得很多系统管理功能难以实现（如权限管理）</p>
<h2 id="对象-关系数据库"><a href="#对象-关系数据库" class="headerlink" title="对象-关系数据库"></a>对象-关系数据库</h2><blockquote>
<p>对象-关系数据库就是是把面向对象方法学与关系数据库系统技术相结合的产物</p>
<p>研究以关系数据库和SQL为基础的扩展关系模型；以面向对象的程序设计语言为基础，研究持久的程序设计语言，支持OO模型；建立新的面向对象数据库系统，支持OO数据模型。</p>
</blockquote>
<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>官网：<a href="https://www.enterprisedb.com/downloads/postgres-postgresql-downloads" target="_blank" rel="noopener">https://www.enterprisedb.com/downloads/postgres-postgresql-downloads</a></p>
<p>国内：<a href="http://www.postgres.cn/download" target="_blank" rel="noopener">http://www.postgres.cn/download</a></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ul>
<li>Windows：…</li>
</ul>
<p>  <img src="C:%5CUsers%5C11240%5CDesktop%5Csetup.png" alt="setup"></p>
<ul>
<li><p>Ubuntu:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install postgresql postgre-client</span><br></pre></td></tr></table></figure>
</li>
<li><p>MacOS:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（贫穷使我快乐</span><br></pre></td></tr></table></figure>

<p>:cry::cry::cry:</p>
</li>
</ul>
<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p><strong>1. pgAdmin(图形化工具）</strong></p>
<p><strong>2. psql(命令行工具)</strong></p>
<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><ul>
<li><p><strong>数据库:</strong> 数据库是一些关联表的集合。</p>
</li>
<li><p><strong>数据表:</strong> 表是数据的矩阵。在一个数据库中的表看起来像一个简单的电子表格。</p>
</li>
<li><p><strong>列:</strong> 一列(数据元素) 包含了相同的数据, 例如邮政编码的数据。</p>
</li>
<li><p><strong>行：</strong>一行（=元组，或记录）是一组相关的数据，例如一条用户订阅的数据。</p>
</li>
<li><p><strong>*冗余</strong>：存储两倍数据，冗余降低了性能，但提高了数据的安全性。</p>
</li>
<li><p><strong>主键</strong>：主键是唯一的。一个数据表中只能包含一个主键。你可以使用主键来查询数据。</p>
</li>
<li><p><strong>外键：</strong>外键用于关联两个表。</p>
</li>
<li><p><strong>复合键</strong>：复合键（组合键）将多个列作为一个索引键，一般用于复合索引。</p>
</li>
<li><p><strong>索引：</strong>使用索引可快速访问数据库表中的特定信息。索引是对数据库表中一列或多列的值进行排序的一种结构。类似于书籍的目录。</p>
</li>
<li><p><strong>*参照完整性:</strong> 参照的完整性要求关系中不允许引用不存在的实体。与实体完整性是关系模型必须满足的完整性约束条件，目的是保证数据的一致性。</p>
</li>
<li><p><strong>*触发器</strong>：触发器是由SQL语句查询所触发的事件。如：一个INSERT语句可能触发一个检查数据完整性的触发器。触发器通常由INSERT或UPDATE语句触发。</p>
<p>在PostgreSQL中，可在数据表上设置<a href="https://zh.wikipedia.org/wiki/触发器_(数据库)" target="_blank" rel="noopener">触发器</a>，但无法在视图中设置(对视图的UPDATE或者INSERT操作可以使用规则（RULE）定义）。多个触发器可依据字母顺序依次执行。此外，除了使用内嵌的PL/PgSQL语言之外，触发器的函数也可以用PL/Perl，PL/Python等语言编写。</p>
</li>
</ul>
<h2 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h2><ul>
<li><p><strong>*函数</strong>：通过函数，可以在数据库服务器端执行指令程序。</p>
</li>
<li><p><strong>索引</strong>：用户可以自定义索引方法，或使用内置的 B 树，哈希表与 GiST 索引。</p>
</li>
<li><p><strong>触发器</strong>：触发器是由SQL语句查询所触发的事件。如：一个INSERT语句可能触发一个检查数据完整性的触发器。触发器通常由INSERT或UPDATE语句触发。 多版本并发控制：PostgreSQL使用多版本并发控制（MVCC，Multiversion concurrency control）系统进行并发控制，该系统向每个用户提供了一个数据库的”快照”，用户在事务内所作的每个修改，对于其他的用户都不可见，直到该事务成功提交。</p>
</li>
<li><p><strong>规则</strong>：规则（R·1LE）允许一个查询能被重写，通常用来实现对视图（VIEW）的操作，如插入（INSERT）、更新（UPDATE）、删除（DELETE）。</p>
</li>
<li><p><strong>数据类型</strong>：包括文本、任意精度的数值数组、JSON 数据、枚举类型、XML 数据</p>
<p>等。</p>
</li>
<li><p><strong>全文检索</strong>：通过 Tsearch2 或 OpenFTS，8.3版本中内嵌 Tsearch2。</p>
</li>
<li><p><strong>NoSQL</strong>：JSON，JSONB，XML，HStore 原生支持，至 NoSQL 数据库的外部数据包装器。</p>
</li>
<li><p><strong>*数据仓库</strong>：能平滑迁移至同属 PostgreSQL 生态的 GreenPlum，DeepGreen，HAWK 等，使用 FDW 进行 ETL。</p>
</li>
</ul>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>枚举类型、几何类型、网络地址类型、XML类型、JSON类型、数组类型、对象标识类型。。。</p>
<h4 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TYPE</span> mood <span class="keyword">AS</span> ENUM (<span class="string">'happy'</span>,<span class="string">'sad'</span>,<span class="string">'我太难了'</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TYPE</span> <span class="keyword">week</span> <span class="keyword">AS</span> ENUM (<span class="string">'Mon'</span>,<span class="string">'Tue'</span>,<span class="string">'Wed'</span>,<span class="string">'Thu'</span>,<span class="string">'Fri'</span>,<span class="string">'Sat'</span>,<span class="string">'Sun'</span>,<span class="string">'996'</span>)</span><br></pre></td></tr></table></figure>

<h4 id="几何类型"><a href="#几何类型" class="headerlink" title="几何类型"></a>几何类型</h4><p><img src="C:%5CUsers%5C11240%5CDesktop%5C%E5%9B%BE%E8%A1%A8.png" alt="图表"></p>
<h4 id="JSON类型"><a href="#JSON类型" class="headerlink" title="JSON类型"></a>JSON类型</h4><ul>
<li><p>json 数据类型可以用来存储 JSON（JavaScript Object Notation）数据， 这样的数据也可以存储为 text，但是 json 数据类型更有利于检查每个存储的数值是可用的 JSON 值。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">#作为JSON数组返回该数组</span></span><br><span class="line">array_to_json('&#123;&#123;1,5&#125;,&#123;99,100&#125;&#125;'::int[])         [[1,5],[99,100]]</span><br><span class="line"></span><br><span class="line"><span class="comment">#作为JSON对象返回行</span></span><br><span class="line">row_to_json(row(1,'foo'))						&#123;"f1":1,"f2":"foo"&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> shop (</span><br><span class="line">	<span class="keyword">name</span> <span class="built_in">text</span>,</span><br><span class="line">    good <span class="built_in">text</span>[],</span><br><span class="line">    price <span class="built_in">integer</span>[],</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> shop</span><br><span class="line">	VALUSE (<span class="string">'五栋小卖部'</span>,</span><br><span class="line">    <span class="string">'&#123;"bread","beverage","snack"&#125;'</span>,</span><br><span class="line">    <span class="string">'&#123;3,5,10&#125;'</span>);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">UPDATE</span> shop <span class="keyword">SET</span> good = <span class="string">'&#123;"bread","beverage","snack","cup","slippers"&#125;'</span> <span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">'五栋小卖部'</span></span><br></pre></td></tr></table></figure>

<h4 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h4><p><img src="C:%5CUsers%5C11240%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1566550083876.png" alt="1566550083876"></p>
<h2 id="基本操作（从删库到跑路）"><a href="#基本操作（从删库到跑路）" class="headerlink" title="基本操作（从删库到跑路）"></a>基本操作（从删库到跑路）</h2><ul>
<li><p>创建数据库</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> dbname;</span><br></pre></td></tr></table></figure>
</li>
<li><p>选择数据库</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查询已经存在的数据库</span></span><br><span class="line">postgres=<span class="comment"># \l</span></span><br><span class="line"><span class="comment">#切换到指定数据库</span></span><br><span class="line">postgres=<span class="comment"># \c + dbname</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>删除数据库</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">DATABASE</span> [<span class="keyword">IF</span> EXITS ] dbname</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建表格</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name(</span><br><span class="line">   column1 datatype,</span><br><span class="line">   column2 datatype,</span><br><span class="line">   column3 datatype,</span><br><span class="line">   .....</span><br><span class="line">   columnN datatype,</span><br><span class="line">   PRIMARY <span class="keyword">KEY</span>( 一个或多个列 )</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除表格</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line"><span class="comment">#查询所有表格</span></span><br><span class="line">postgres=<span class="comment"># \d</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>增、删、改、查</p>
</li>
<li><p>当作对象数据库使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">	String id;</span><br><span class="line">	String title;</span><br><span class="line">	List&lt;Author&gt; authors;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Author</span> </span>&#123;</span><br><span class="line">	String id;</span><br><span class="line">	String name;</span><br><span class="line">	List&lt;Book&gt; books;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> book &#123;</span><br><span class="line">	<span class="keyword">id</span> <span class="built_in">character</span> <span class="built_in">varying</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">	title <span class="built_in">character</span> <span class="built_in">varying</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">	<span class="keyword">authors</span> <span class="built_in">character</span> <span class="built_in">varying</span>[] <span class="keyword">COMMENT</span> <span class="string">'ref: author.id'</span>,</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> author &#123;</span><br><span class="line">	<span class="keyword">id</span> <span class="built_in">character</span> <span class="built_in">varying</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">	<span class="keyword">name</span> <span class="built_in">character</span> <span class="built_in">varying</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">	books <span class="built_in">character</span> <span class="built_in">varying</span>[] <span class="keyword">COMMENT</span> <span class="string">'ref: book.id'</span>,</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h4 id="模式（SCHEMA）"><a href="#模式（SCHEMA）" class="headerlink" title="模式（SCHEMA）"></a>模式（SCHEMA）</h4><p>PostgreSQL 模式（SCHEMA）可以看着是一个表的集合。一个模式可以包含视图、索引、数据类型、函数和操作符等。另外，可以使用带模式的完整名称来访问或者创建对象。</p>
<ul>
<li>允许多个用户使用一个数据库并且不会互相干扰。</li>
<li>将数据库对象组织成逻辑组以便更容易管理。</li>
<li>第三方应用的对象可以放在独立的模式中，这样它们就不会与其他对象的名称发生冲突。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">#创建一个模式</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">SCHEMA</span> schema_name</span><br><span class="line"><span class="comment">#删除一个模式</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">SCHEMA</span> chema_name;</span><br><span class="line"><span class="comment">#删除一个模式以及其中包含的所有对象</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">SCHEMA</span> myschema_name <span class="keyword">CASCADE</span>;</span><br></pre></td></tr></table></figure>

<h4 id="视图（VIEW）"><a href="#视图（VIEW）" class="headerlink" title="视图（VIEW）"></a>视图（VIEW）</h4><p>视图是一个基于一个或多个表的数据定义的虚拟表。视图是没有数据的，视图里面的数据都是来自实际的表。</p>
<ul>
<li><p>用户或用户组认为更自然或直观查找结构数据的方式。</p>
</li>
<li><p>限制数据访问，用户只能看到有限的数据，而不是完整的表。</p>
</li>
<li><p>汇总各种表中的数据，用于生成报告。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [TEMP | <span class="keyword">TEMPORARY</span>] <span class="keyword">VIEW</span> view_name <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> column1, column2.....</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> [condition];</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> COMPANY;</span><br><span class="line"> id | name  | age | address   | salary</span><br><span class="line"><span class="comment">----+-------+-----+-----------+--------</span></span><br><span class="line">  1 | Paul  |  32 | California|  20000</span><br><span class="line">  2 | Allen |  25 | Texas     |  15000</span><br><span class="line">  3 | Teddy |  23 | Norway    |  20000</span><br><span class="line">  4 | Mark  |  25 | Rich-Mond |  65000</span><br><span class="line">  5 | David |  27 | Texas     |  85000</span><br><span class="line">  6 | Kim   |  22 | South-Hall|  45000</span><br><span class="line">  7 | James |  24 | Houston   |  10000</span><br><span class="line">(7 rows)</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> COMPANY_VIEW <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">ID</span>, <span class="keyword">NAME</span>, AGE</span><br><span class="line"><span class="keyword">FROM</span>  COMPANY;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> COMPANY_VIEW;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">id | name  | age</span><br><span class="line"><span class="comment">----+-------+-----</span></span><br><span class="line">  1 | Paul  |  32</span><br><span class="line">  2 | Allen |  25</span><br><span class="line">  3 | Teddy |  23</span><br><span class="line">  4 | Mark  |  25</span><br><span class="line">  5 | David |  27</span><br><span class="line">  6 | Kim   |  22</span><br><span class="line">  7 | James |  24</span><br><span class="line">(7 rows)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="继承（inheritance）"><a href="#继承（inheritance）" class="headerlink" title="继承（inheritance）"></a>继承（inheritance）</h4><p><strong>PostgreSQL</strong> 支持高级的 <strong>objdect-relational</strong> 机制，继承。继承允许一张表继承一张（或多张）表的列属性，来建立 <strong>parent-child</strong>关系。子表可以继承父表的字段以及约束，同时可以拥有自己的字段。</p>
<p>当执行一个父表查询的时候，这个查询可以获取来自本表和它的子表，也可以指定只查询本表。在子表中查询，则不会返回父表的数据。</p>
<ul>
<li>让我们从一个例子开始：假设我们试图制作一个城市数据模型。每个省都有许多城市，但是只有一个省会。我们希望能够迅速检索任何一个省的省会。这个任务可以通过创建两个表来实现，一个是省会表，一个是非省会表。不过，如果我们不管什么城市都想查该怎么办?继承的特性可以帮助我们解决这个问题。我们定义 <code>capitals</code> 表，它继承自 <code>cities</code> 表：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> cities (</span><br><span class="line">    <span class="keyword">name</span>            <span class="built_in">text</span>,</span><br><span class="line">    population      <span class="built_in">float</span>,</span><br><span class="line">    altitude        <span class="built_in">int</span>     <span class="comment">-- 英尺</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> capitals (</span><br><span class="line">    state           <span class="built_in">char</span>(<span class="number">2</span>)</span><br><span class="line">) INHERITS (cities);</span><br></pre></td></tr></table></figure>

<p><strong>注：</strong>在 PostgreSQL 里，一个表可以从零个或多个其它表中继承属性</p>
<ul>
<li><strong>ONLY</strong>关键字</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span>, altitude</span><br><span class="line">    <span class="keyword">FROM</span> cities</span><br><span class="line">    <span class="keyword">WHERE</span> altitude &gt; <span class="number">500</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">   name    | altitude</span><br><span class="line"><span class="comment">-----------+----------</span></span><br><span class="line"> Rikaze    |     4000</span><br><span class="line"> Lasa      |	 3658</span><br><span class="line"> Kunming   |     1891.4</span><br><span class="line"> Chengdu   |     505.9</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span>, altitude</span><br><span class="line">    <span class="keyword">FROM</span> <span class="keyword">ONLY</span> cities</span><br><span class="line">    <span class="keyword">WHERE</span> altitude &gt; <span class="number">500</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-----------+----------</span></span><br><span class="line"> Rikaze    |     4000</span><br></pre></td></tr></table></figure>

<p><strong>注：</strong><code>cities</code> 前面的 <code>ONLY</code> 表明该查询应该只针对 <code>cities</code> 而不包括其后代。许多我们已经讨论过的命令(<code>SELECT</code>, <code>UPDATE</code>, <code>DELETE</code>)都支持 <code>ONLY</code> 关键字</p>
<ul>
<li><p>有时候你可能想知道某个行版本来自哪个表。在每个表里我们都有一个 <code>tableoid</code> 系统属性可以告诉你源表是谁：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> c.tableoid, c.name, c.altitude</span><br><span class="line"><span class="keyword">FROM</span> cities c</span><br><span class="line"><span class="keyword">WHERE</span> c.altitude &gt; <span class="number">500</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"> tableoid |   name    | altitude</span><br><span class="line"><span class="comment">----------+-----------+----------</span></span><br><span class="line">   139793 |  Rikaze    |     4000</span><br><span class="line">   139793 |	 Lasa      |	 3658</span><br><span class="line">   139798 |	 Kunming   |     1891.4</span><br><span class="line">   139797 |	 Chengdu   |     505.9</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="聊聊PostgreSQL"><a href="#聊聊PostgreSQL" class="headerlink" title="聊聊PostgreSQL"></a>聊聊PostgreSQL</h2><ul>
<li>PostgreSQL这么强大，为什么在国内其流行度远不如MySQL？<ol>
<li>中国第一次互联网浪潮的时候（2000年左右），PostgreSQL在性能、易用性和对Windows的支持远远不如MySQL，所以尽管现在的PostgreSQL或许比MySQL好，但已经错失了一个重要的时机，想要代替MySQL需要很大努力。</li>
<li>现在使用MySQL的人非常多，社区也比PostgreSQL成熟，其遇到的问题也基本有解。而PostgreSQL没有高水平的团队的话一般不会轻易尝试。</li>
</ol>
</li>
</ul>
<h2 id="可视化工具"><a href="#可视化工具" class="headerlink" title="可视化工具"></a>可视化工具</h2><ul>
<li><p>Navicat</p>
</li>
<li><p>Mysql Workbench</p>
<p><strong>MySQL Workbench</strong>是一个可视化<a href="https://en.wikipedia.org/wiki/Database_design" target="_blank" rel="noopener">数据库设计</a>工具，它将<a href="https://en.wikipedia.org/wiki/SQL" target="_blank" rel="noopener">SQL </a><a href="https://en.wikipedia.org/wiki/Software_development" target="_blank" rel="noopener">开发</a>，<a href="https://en.wikipedia.org/wiki/Database_administration" target="_blank" rel="noopener">管理</a>，<a href="https://en.wikipedia.org/wiki/Database_design" target="_blank" rel="noopener">数据库设计</a>，创建和维护<a href="https://en.wikipedia.org/wiki/Integrated_development_environment" target="_blank" rel="noopener">集成</a>到<a href="https://en.wikipedia.org/wiki/MySQL" target="_blank" rel="noopener">MySQL</a>数据库系统的单一<a href="https://en.wikipedia.org/wiki/Integrated_development_environment" target="_blank" rel="noopener">集成开发环境</a>中。它是fabFORCE.net的DBDesigner 4的继承者，取代了以前的软件包<a href="https://en.wikipedia.org/wiki/MySQL_Workbench#MySQL_GUI_Tools_Bundle" target="_blank" rel="noopener">MySQL GUI Tools Bundle</a>。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>后端</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>高性能MySQL第一章笔记</title>
    <url>/2019/11/03/%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E7%AC%AC%E4%B8%80%E7%AB%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="高性能MySQL"><a href="#高性能MySQL" class="headerlink" title="高性能MySQL"></a>高性能MySQL</h2><h3 id="逻辑架构"><a href="#逻辑架构" class="headerlink" title="逻辑架构"></a>逻辑架构</h3><p><img src="https://pic002.cnblogs.com/images/2012/152332/2012031510324452.png" alt="逻辑架构">·</p>
<ul>
<li>第一层： 连接处理，授权认证</li>
<li>第二层： MySQL的核心部分（查询、解析、优化、缓存），实现存储过程、视图、触发器。</li>
<li>第三层：存储引擎层，主要负责数据的存储和提取。<em>注：存储引擎不会去解析SQL</em></li>
</ul>
<h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><ul>
<li>在MySQL中一个连接对应一个线程，每个连接的查询只会单独在单独的线程中进行，而线程只会轮流在某个CPU核心或者CPU中运行。</li>
</ul>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><ul>
<li><p>MySQL 会解析查询，并创建内部的数据结构（解析树），然后对其进行优化，包括重写查询，决定表的读取顺序，以及选择合适的索引。用户可以使用特殊关键字提示优化器，影响他的决策。</p>
</li>
<li><p>优化器不关心使用的存储引擎，但存储引擎会对优化查询有影响。</p>
</li>
<li><p>对于SELECT语句，在解析查询前，服务器会先检查缓存，如果能找到对应的查询，服务器将不必再执行解析，优化和执行的整个过程。</p>
</li>
</ul>
<h3 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h3><ul>
<li>只要多个查询在同一时刻修改数据，就会产生并发控制的问题。</li>
<li>MySQL主要从服务器层和存储引擎两个层面处理并发控制。</li>
</ul>
<h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><ul>
<li>对于一个邮箱读取操作，即使同一时刻有多个用户并发读取也不会有什么问题，但如果某个用户正在再读取邮箱，同时另外一个用户试图删除此邮件，那可能就会产生意料之外的结果。所以，即使读取操作，也需要注意。</li>
<li>解决这类问题的办法就是并发控制。其实就是在处理并发读或者写的时候，通过实现一个由两种类型的锁组成的锁系统来解决问题。这两种类型的锁一般称为共享锁和排他锁，也叫读锁和写锁。</li>
<li>读锁是共享的，或者说相互不阻塞。多个客户在同一时刻可以同时读取同一资源，互不干扰。</li>
<li>写锁是排他的，也就是说一个写锁会阻塞其他的写锁和读锁。</li>
</ul>
<h3 id="锁粒度"><a href="#锁粒度" class="headerlink" title="锁粒度"></a>锁粒度</h3><ul>
<li>一种提高共享资源并发性的方式就是让锁对象更具有选择性。锁定的数据量越少，系统的并发程度就越高。</li>
<li>加锁需要消耗资源吗。锁的各种操作，包括获取锁，检查锁是否已经解除，释放锁都会增加系统的开销。</li>
<li>所谓锁策略，就是在锁的开销和数据的安全性之间寻求平衡。</li>
<li>而MySQL提供了多种选择，每种MySQL引擎都可以实现自己的所策略和锁粒度</li>
</ul>
<h4 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h4><ul>
<li>表锁是开销最小的锁策略：它会锁定整张表，一个用户在对表进行写操作前，需要先获得写锁，这会阻塞其他用户对该表的读写操作。只有当写锁不存在的时候，其他用户才能获取读锁。</li>
<li>服务器在使用ALTER TABLE时会使用表锁，而忽略存储引擎的锁机制。</li>
</ul>
<h4 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h4><ul>
<li>行级锁可以最大程度地支持并发处理（但同时也带来了最大的锁开销）。在InnoDB和XtraDB，以及一些其它存储引擎实现了行级锁。行级锁只在存储引擎层实现，而MySQL服务器层没有实现。</li>
</ul>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><ul>
<li>事务是数据库执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成。<h4 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h4></li>
<li>原子性：事务中的所有操作被作为一个整体执行，要么全部执行，要么全部不执行（不能只执行其中一部分）</li>
<li>一致性： 数据库总是从一个一致性的状态转换到另外一个一致性的状态。一致状态是指数据库状态应满足完整性约束。</li>
<li>隔离性：一个事务所做的修改在最终提交以前，对其他事务是不可见的。（即一个事务不会影响另一个事务的执行）</li>
<li>持久性：事务一旦提交，就会被永久的保存到数据库中，即使系统崩溃，修改的数据也不会丢失。</li>
<li>就像锁粒度升级会增加系统开销一样，实现了ACID的数据库相对于没有实现ACID的数据，所需要的CPU、内存、磁盘空间更大。</li>
</ul>
<h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><ul>
<li><p>未提交读（<strong>READ UNCOMMITED</strong>)：事务中的修改，即使没有提交，对其他事务也是可见的。（这种情况容易造成脏读<br><em>脏读又称无效数据的读出，是指在数据库访问中，事务T1将某一值修改，然后事务T2读取该值，此后T1因为某种原因撤销对该值的修改，这就导致了T2所读取到的数据是无效的。</em></p>
</li>
<li><p>提交读(<strong>READ COMMITED</strong>)：大多数数据库默认隔离级别都是提交读（MySQL是可重复读）。所谓提交读，就是指一个事务从开始直到提交前，所做的任何操作修改对其他事务都是不可见的。</p>
</li>
<li><p>可重复读(<strong>REPETABLE READ</strong>)：可重复度解决了脏读的问题，但还是没办法解决幻读。所谓幻读，指的是当事务A在某个范围进行查询操作时，事务B又在该范围执行了<strong>Insert</strong>或<strong>Delete</strong>操作，当事务A再次读取该范围的记录时，会得到两个不一样的数据。</p>
</li>
<li><p>可串行化(<strong>SERIALIZABLE</strong>)：可窜行化会在读取的每一行的数据上都加锁，所以可能会导致大量的超时和锁争用的问题。（只有在非常需要确保数据的一致性而且可以接受没有并发的情况下，才考虑采用该级别。）</p>
</li>
<li><p>MySQL默认采用自动提交模式。如果不是显式地开始一个事务，则每个查询都被当作一个事务执行提交操作。另外，在执行ALTER TABEL命令时，会强制执行COMMIT操作。</p>
</li>
</ul>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><ul>
<li>死锁是指两个或者多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致二型循环的现象。</li>
</ul>
<h3 id="多版本并发控制（MVCC）"><a href="#多版本并发控制（MVCC）" class="headerlink" title="多版本并发控制（MVCC）"></a>多版本并发控制（MVCC）</h3><ul>
<li>MySQL 的大多数事务性存储引擎实现的都不是简单的行级锁。基于提升并发性能的考虑，它们一般同时实现了多版本并发控制。</li>
<li>可以认为MVCC是行级锁的一个变种，但是它在很多情况下避免了加锁的操作。</li>
<li>不同存储引擎的MVCC实现是不同的，对于InnoDB，是通过在每行的记录后面保存两个隐藏的列实现的。这个两个列，一个保存了行的创建时间，一个保存了行的过期时间。（这里的时间不是指实际的时间，而是指系统的版本号。）<h4 id="可重复读的具体实现如下"><a href="#可重复读的具体实现如下" class="headerlink" title="可重复读的具体实现如下:"></a>可重复读的具体实现如下:</h4><h5 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h5>a.InnoDB 只查找版本早于当前事务的数据行。这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是已经修改完成的。<br>b.行的删除版本要么未定义，要么大于当前事务版本号。这可以确保事务读取到的行，在事务开始之前未被删除。</li>
</ul>
<h5 id="INSERT"><a href="#INSERT" class="headerlink" title="INSERT"></a>INSERT</h5><pre><code>InnoDB为新插入的每一行保存当前系统版本号作为行版本号。</code></pre><h5 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h5><pre><code>InnoDB为删除的每一行保存当前系统版本号作为删除标识。</code></pre><h5 id="UPDATE"><a href="#UPDATE" class="headerlink" title="UPDATE"></a>UPDATE</h5><pre><code>InnoDB为插入一行新纪录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为删除标识符。</code></pre><p>保存这两个额外系统版本号， 使大多数操作都可以不用加锁。这样操作使得读数据操作很简单，性能很好，并且能保证只会读取到符合标准的行。不足之处是每行纪录都需要额外的存储空间，需要做更多的行检查工作，以及一些额外的维护工作。</p>
<p>MVCC只在可重复读和只读两个隔离级别下工作。其他两个隔离级别都与MVCC不兼容。</p>
<h3 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h3><h4 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h4><ul>
<li><p>InnoDB采用MVCC支持高并发，并且实现了四个标准的隔离级别。其默认级别是可重复读，并且通过<strong>间隙锁</strong>策略防止幻读的出现。</p>
</li>
<li><p>InnoDB是基于聚簇索引建立的，聚簇索引对逐渐查询有很高的性能，但它的二级索引中必须包含主键列，所以如果主键列很打的话，其他的所有索引都会很大。</p>
</li>
<li><p>InnoDB支持索引，外键，并采用了行级锁。</p>
</li>
</ul>
<h4 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h4><ul>
<li>MyISAM相对于InnoDB的一个缺陷就是崩溃后无法安全恢复</li>
<li>MyISAM会<strong>对整张表加锁</strong>，而不是采用行级锁</li>
<li>MyISAM支持全文索引，也可以使用mysiampack对MyISAM表进行压缩。（压缩之后的表不能进行修改，压缩表可以极大地减少磁盘空间占用）</li>
</ul>
<h3 id="转换表的引擎"><a href="#转换表的引擎" class="headerlink" title="转换表的引擎"></a>转换表的引擎</h3><p>1.ALTER TABLE</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE mytable ENGINE = InnoDB;</span><br></pre></td></tr></table></figure>

<p>该方法需要执行很长时间，在复制期间可能会消耗系统所有的I/O能力，同时原表上会加上读锁。</p>
<p>2.通过mysqldump工具将数据库文件导出，然后修改文件中CREATE TABLE 中的存储引擎选项，同时注意修改表名。</p>
<p>3.创建与查询</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE innodb_table like mysiam_table</span><br><span class="line">ALTER TABLE innodb_table engine = InnoDB</span><br><span class="line">INSERT INTO innodb_table select * from myisam_table</span><br></pre></td></tr></table></figure>

<p>如果数据量过大的话，则可以考虑做分批处理，针对每一段数据执行事务提交数据操作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">STARAT TRANSACTION;</span><br><span class="line">INSERT INIO innodb_table select * from mysiam_table WHERE id BETWEEN x and y;</span><br><span class="line">COMMIT;</span><br></pre></td></tr></table></figure>

<h3 id="选择合适的引擎"><a href="#选择合适的引擎" class="headerlink" title="选择合适的引擎"></a>选择合适的引擎</h3><ul>
<li><p>“除非需要用到某些InnoDB 不具备的特性，并且没有其他办法可以替代，否则都应该InnoDB引擎”。</p>
</li>
<li><p>如果要使用全文索引，优先考虑InnoDB加上Sphinx组合，而不是使用支持全文索引的MyISAM。</p>
</li>
<li><p>如果不是万不得已，否则建议不要混合使用存储引擎。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>后端</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Channel</title>
    <url>/2019/11/02/Channel/</url>
    <content><![CDATA[<h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><h3 id="Channel的基本语法"><a href="#Channel的基本语法" class="headerlink" title="Channel的基本语法"></a>Channel的基本语法</h3><p>如果说goroutine是Go语言程序的并发体的话，那么channels则是它们之间的通信机制。使用channel，我们可以在两个goroutine之间通信（传输数据）。</p>
<p>使用内置的make函数，我们可以创建一个channel：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>) <span class="comment">// ch的数据类型是chan int</span></span><br></pre></td></tr></table></figure>

<p>一个channel有发送和接受两个主要操作。发送和接收两个操作都使用<code>&lt;-</code>运算符。在发送语句中，<code>&lt;-</code>运算符分割channel和要发送的值。在接收语句中，<code>&lt;-</code>运算符写在channel对象之前。一个不使用接收结果的接收操作也是合法的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch &lt;- x  <span class="comment">// 将变量x发送给管道ch</span></span><br><span class="line">x = &lt;-ch <span class="comment">// 变量x接受管道ch发送过来的值</span></span><br><span class="line">&lt;-ch     <span class="comment">// 接受管道ch发送过来的值，但不使用</span></span><br></pre></td></tr></table></figure>



<h4 id="不带缓存的channel"><a href="#不带缓存的channel" class="headerlink" title="不带缓存的channel"></a>不带缓存的channel</h4><p>一个基于无缓存Channels的发送操作将导致发送者goroutine阻塞，直到另一个goroutine在相同的Channels上执行接收操作，当发送的值通过Channels成功传输之后，两个goroutine可以继续执行后面的语句。反之，如果接收操作先发生，那么接收者goroutine也将阻塞，直到有另一个goroutine在相同的Channels上执行发送操作。</p>
<p>不带缓存的channel的声明方式</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch = <span class="built_in">make</span>(<span class="keyword">chan</span> T) <span class="comment">//可以接收和发送类型为 T 的数据</span></span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ch <span class="keyword">chan</span> T  <span class="comment">// 可以接收和发送类型为 T 的数据</span></span><br></pre></td></tr></table></figure>

<p>我们来看一个栗子</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> channel = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	<span class="keyword">var</span> send = <span class="number">6666</span></span><br><span class="line">    <span class="comment">// 关键字go后跟的是需要被并发执行的代码块，它由一个匿名函数代表</span></span><br><span class="line">    <span class="comment">// 在这里，我们只要知道在花括号中的就是将要被并发执行的代码就可以</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		channel &lt;- send</span><br><span class="line">		fmt.Println(<span class="string">"数据已发送"</span>)</span><br><span class="line">	&#125;()</span><br><span class="line">    <span class="comment">// 这里让主线程休眠1秒钟</span></span><br><span class="line">    <span class="comment">// 以使上面的goroutine有机会被执行</span></span><br><span class="line">    time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行上述代码后，我们发现控制台并没有输出“数据已发送”这几个字样。这是因为我们只向channel传递了sent的值，而没有从channel中取出，从而导致当前goroutine被阻塞，也就是Println这条语句没有被执行。</p>
<p>为此我们稍作改进:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> channel = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	<span class="keyword">var</span> send = <span class="number">6666</span></span><br><span class="line">	<span class="keyword">var</span> receive <span class="keyword">int</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 向channel中传递sent的值</span></span><br><span class="line">		channel &lt;- send</span><br><span class="line">		fmt.Println(<span class="string">"数据已发送"</span>)</span><br><span class="line">	&#125;()</span><br><span class="line">    <span class="comment">// 使用receive接受从channel中传来的值</span></span><br><span class="line">	receive = &lt;- channel</span><br><span class="line">	fmt.Println(receive)</span><br><span class="line">	time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">数据已发送</span><br><span class="line"><span class="number">6666</span></span><br></pre></td></tr></table></figure>

<p>我们成功地接受到了channel中的值，并解决了goroutine的阻塞问题。（只有channel的接收者，也会导致当前goroutine的阻塞，感兴趣的同学可以自己模拟实现下）</p>
<h3 id="带缓存的Channel"><a href="#带缓存的Channel" class="headerlink" title="带缓存的Channel"></a>带缓存的Channel</h3><p>带缓存的Channel内部持有一个元素队列。队列的最大容量是在调用make函数创建channel时通过第二个参数指定的。下面的语句创建了一个可以持有三个字符串元素的带缓存Channel。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p>我们可以在无阻塞的情况下连续向新创建的channel发送三个值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch &lt;- <span class="string">"A"</span></span><br><span class="line">ch &lt;- <span class="string">"B"</span></span><br><span class="line">ch &lt;- <span class="string">"C"</span></span><br></pre></td></tr></table></figure>

<p>但当我们发送第四个数据的时候，就会造成当前goroutine的阻塞</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 声明了一个带有3个缓存空间的channel</span></span><br><span class="line">	<span class="keyword">var</span> channel = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		channel &lt;- <span class="string">"A"</span></span><br><span class="line">		channel &lt;- <span class="string">"B"</span></span><br><span class="line">		channel &lt;- <span class="string">"C"</span></span><br><span class="line">		fmt.Println(<span class="string">"我发送了3个数据"</span>)</span><br><span class="line">        <span class="comment">// 当发送第四个值的时候，goroutine阻塞</span></span><br><span class="line">		channel &lt;- <span class="string">"D"</span></span><br><span class="line">		fmt.Println(<span class="string">"我发送了第4个数据"</span>)</span><br><span class="line">	&#125;()</span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">我发送了<span class="number">3</span>个数据</span><br></pre></td></tr></table></figure>

<h3 id="Range-amp-Close"><a href="#Range-amp-Close" class="headerlink" title="Range&amp;Close"></a>Range&amp;Close</h3><p><code>for value:=range ch</code>操作可以说是非常熟悉了，当我们遍历slice或者map时也是同样的用法</p>
<p><code>close</code>也就是golang的内置函数，可以用于关闭一个channel</p>
<p>对一个已经被close过的channel进行接收操作依然可以接受到之前已经成功发送的数据</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(n <span class="keyword">int</span>, c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	x, y := <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">		c &lt;- x</span><br><span class="line">		x, y = y, x + y <span class="comment">//交换变量的便利写法</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">close</span>(c) <span class="comment">//关闭通道</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line">	<span class="keyword">go</span> fibonacci(<span class="built_in">cap</span>(c), c) <span class="comment">//cap(c)即为c的容量大小</span></span><br><span class="line">    <span class="comment">// 不断读取channel数据，直到channel被显式关闭</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> c &#123; </span><br><span class="line">		fmt.Println(i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>记住应该在生产者的地方关闭channel，而不是消费的地方去关闭它，这样容易引起panic。</p>
<p>另外，关闭一个已经被关闭的channel也将导致panic。</p>
<h3 id="单方向的Channel"><a href="#单方向的Channel" class="headerlink" title="单方向的Channel"></a>单方向的Channel</h3><p>前面我们提到，channel具有接受和发送两种操作，但如果我们只想要一个具有发送功能的channel应该怎么办呢？</p>
<p>Go语言的类型系统提供了单方向的channel类型，分别用于只发送或只接收的channel。</p>
<p>类型<code>chan&lt;- int</code>表示一个只发送int的channel，只能发送不能接收。相反，类型<code>&lt;-chan int</code>表示一个只接收int的channel，只能接收不能发送。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	send := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	<span class="keyword">go</span> counter(send)</span><br><span class="line">	squarer(send)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">counter</span><span class="params">(out <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> x := <span class="number">0</span>; x &lt; <span class="number">100</span>; x++ &#123;</span><br><span class="line">		out &lt;- x</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">close</span>(out)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">squarer</span><span class="params">(in &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> v := <span class="keyword">range</span> in &#123;</span><br><span class="line">		fmt.Println(v)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="通道死锁"><a href="#通道死锁" class="headerlink" title="通道死锁"></a>通道死锁</h3><p>通道两段互相阻塞对方，会形成死锁状态。Go运行时会检查并panic，停止程序。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	out := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	out &lt;- <span class="number">2</span></span><br><span class="line">	<span class="keyword">go</span> f1(out)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f1</span><span class="params">(in <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	fmt.Println(&lt;-in)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fatal error: all goroutines are asleep - deadlock!</span><br></pre></td></tr></table></figure>

<p>显然在<code>out &lt;- 2</code>的时候，由于没有接受者，主线程被阻塞。</p>
<h2 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h2><p><code>select</code> 是一种与 <code>switch</code> 非常相似的控制结构，与 <code>switch</code> 不同的是，<code>select</code> 中虽然也有多个 <code>case</code>，但是这些 <code>case</code> 中的表达式都必须与 Channel的操作有关，也就是 Channel 的读写操作，下面的函数就展示了一个包含从 Channel 中读取数据和向 Channel 发送数据的 <code>select</code> 结构：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(ch, quit <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	x, y := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> ch &lt;- x:</span><br><span class="line">			x, y = y, x+y</span><br><span class="line">		<span class="keyword">case</span> &lt;-quit:</span><br><span class="line">			fmt.Println(<span class="string">"quit"</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span> )</span><br><span class="line">	quit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span> ; i++ &#123;</span><br><span class="line">			<span class="comment">// 接受通道c传来的值，并打印到控制台</span></span><br><span class="line">			fmt.Println(&lt;-c)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 当协程执行完上述操作后，向quit发送数据</span></span><br><span class="line">		quit &lt;- <span class="number">0</span></span><br><span class="line">	&#125;()</span><br><span class="line">	fibonacci(c, quit)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到这里，我们可能会疑惑，如果同时有多个case需要处理，那怎么办？</p>
<p>如果多个case同时就绪时，select会随机地选择一个执行，这样来保证每一个channel都有平等的被select的机会</p>
<p>如果没有case需要处理，则会选择<code>default</code>去处理，若没有<code>default</code>语句时则<code>select</code>语句会被阻塞（<code>select</code>默认为阻塞），直到某个case需要处理</p>
]]></content>
      <categories>
        <category>golang基础语法</category>
      </categories>
      <tags>
        <tag>后端</tag>
        <tag>Golang</tag>
      </tags>
  </entry>
</search>
