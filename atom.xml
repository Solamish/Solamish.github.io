<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>个人博客</title>
  
  <subtitle>Solamish的博客小站</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://solamish.github.io/"/>
  <updated>2019-11-02T17:05:50.452Z</updated>
  <id>http://solamish.github.io/</id>
  
  <author>
    <name>Solamish</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>PostgreSQL</title>
    <link href="http://solamish.github.io/2019/11/03/PostgreSQL/"/>
    <id>http://solamish.github.io/2019/11/03/PostgreSQL/</id>
    <published>2019-11-02T17:03:11.000Z</published>
    <updated>2019-11-02T17:05:50.452Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PostgreSQL"><a href="#PostgreSQL" class="headerlink" title="PostgreSQL"></a>PostgreSQL</h1><blockquote><p>PostgreSQL 不寻常的名字导致一些读者停下来尝试拼读它，特别是那些把SQL拼读为”sequel”的人（当然也有人读作“circle”）。PostgreSQL 开发者把它拼读为 “post-gress-Q-L”。它也经常被简略念为 “postgres”。</p><p>PostgreSQL是一个功能强大的开源<strong>对象-关系</strong>数据库系统，经过30多年的积极开发，在可靠性，功能稳健性和性能方面赢得了良好的声誉。</p><p>PostgreSQL是<strong>跨平台</strong>的，可以在许多操作系统上运行，如Linux，FreeBSD，OS X，Solaris和Microsoft Windows等。</p></blockquote><h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><p>PostgreSQL由计算机科学教授Michael Stonebraker在UCB创建。 它最初叫做Postgres。 1986年由Michael Stonebraker教授作为后续项目和Ingres项目启动，克服了当代数据库系统的问题。PostgreSQL现在是任何地方都很先进的开源数据库。</p><h2 id="什么是对象数据库"><a href="#什么是对象数据库" class="headerlink" title="什么是对象数据库"></a>什么是对象数据库</h2><ul><li>面向对象数据库系统(OODBS)支持定义和操作OODB，应满足两个标准：首先它是<strong>数据库系统</strong>，其次它也是<strong>面向对象系统</strong>。第一个标准即作为数据库系统应具备的能力(持久性、事务管理、并发控制、恢复、查询、版本管理、完整性、安全性)。第二个标准就是要求面向对象数据库充分支持完整的面向对象(OO)概念和控制机制。</li><li>在纯对象式数据库中，资料以<strong>对象的形式</strong>存储，这些对象只能由其所属的类中定义的方法来操作。</li><li>它强调高级程序设计语言与数据库的无缝连接。什么是无缝连接，就是你可以编写<strong>不同编程语言</strong>的代码，而<strong>无需重新编译</strong>数据库。<em>eg:你用C语言编了一个程序，你可以不需要（或基本不需要）任何改动就将它作用于数据库，即你可以用C语言透明访问数据库，就好像数据库根本不存在一样。</em>所以也有人把面向对象数据库理解为语言的持久化。</li></ul><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>1.易维护、质量高、高扩展：因为采用了面向对象的思想，使得系统满足高内聚、低耦合的特性，因此在维护、复用、扩展等方面显得非常方便</p><p>2.效率高：在软件开发时，可以根据设计的需要对现实世界的事物进行抽象，产生类。</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>1.标准化：在面向对象数据模型的其它方面，如&amp;体系结构、编程接口语言上的理解尚未达到一致。</p><p>2.模式修改：由于模型较为复杂（而且缺乏数学基础），使得很多系统管理功能难以实现（如权限管理）</p><h2 id="对象-关系数据库"><a href="#对象-关系数据库" class="headerlink" title="对象-关系数据库"></a>对象-关系数据库</h2><blockquote><p>对象-关系数据库就是是把面向对象方法学与关系数据库系统技术相结合的产物</p><p>研究以关系数据库和SQL为基础的扩展关系模型；以面向对象的程序设计语言为基础，研究持久的程序设计语言，支持OO模型；建立新的面向对象数据库系统，支持OO数据模型。</p></blockquote><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>官网：<a href="https://www.enterprisedb.com/downloads/postgres-postgresql-downloads" target="_blank" rel="noopener">https://www.enterprisedb.com/downloads/postgres-postgresql-downloads</a></p><p>国内：<a href="http://www.postgres.cn/download" target="_blank" rel="noopener">http://www.postgres.cn/download</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ul><li>Windows：…</li></ul><p>  <img src="C:%5CUsers%5C11240%5CDesktop%5Csetup.png" alt="setup"></p><ul><li><p>Ubuntu:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install postgresql postgre-client</span><br></pre></td></tr></table></figure></li><li><p>MacOS:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">（贫穷使我快乐</span><br></pre></td></tr></table></figure><p>:cry::cry::cry:</p></li></ul><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p><strong>1. pgAdmin(图形化工具）</strong></p><p><strong>2. psql(命令行工具)</strong></p><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><ul><li><p><strong>数据库:</strong> 数据库是一些关联表的集合。</p></li><li><p><strong>数据表:</strong> 表是数据的矩阵。在一个数据库中的表看起来像一个简单的电子表格。</p></li><li><p><strong>列:</strong> 一列(数据元素) 包含了相同的数据, 例如邮政编码的数据。</p></li><li><p><strong>行：</strong>一行（=元组，或记录）是一组相关的数据，例如一条用户订阅的数据。</p></li><li><p><strong>*冗余</strong>：存储两倍数据，冗余降低了性能，但提高了数据的安全性。</p></li><li><p><strong>主键</strong>：主键是唯一的。一个数据表中只能包含一个主键。你可以使用主键来查询数据。</p></li><li><p><strong>外键：</strong>外键用于关联两个表。</p></li><li><p><strong>复合键</strong>：复合键（组合键）将多个列作为一个索引键，一般用于复合索引。</p></li><li><p><strong>索引：</strong>使用索引可快速访问数据库表中的特定信息。索引是对数据库表中一列或多列的值进行排序的一种结构。类似于书籍的目录。</p></li><li><p><strong>*参照完整性:</strong> 参照的完整性要求关系中不允许引用不存在的实体。与实体完整性是关系模型必须满足的完整性约束条件，目的是保证数据的一致性。</p></li><li><p><strong>*触发器</strong>：触发器是由SQL语句查询所触发的事件。如：一个INSERT语句可能触发一个检查数据完整性的触发器。触发器通常由INSERT或UPDATE语句触发。</p><p>在PostgreSQL中，可在数据表上设置<a href="https://zh.wikipedia.org/wiki/触发器_(数据库)" target="_blank" rel="noopener">触发器</a>，但无法在视图中设置(对视图的UPDATE或者INSERT操作可以使用规则（RULE）定义）。多个触发器可依据字母顺序依次执行。此外，除了使用内嵌的PL/PgSQL语言之外，触发器的函数也可以用PL/Perl，PL/Python等语言编写。</p></li></ul><h2 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h2><ul><li><p><strong>*函数</strong>：通过函数，可以在数据库服务器端执行指令程序。</p></li><li><p><strong>索引</strong>：用户可以自定义索引方法，或使用内置的 B 树，哈希表与 GiST 索引。</p></li><li><p><strong>触发器</strong>：触发器是由SQL语句查询所触发的事件。如：一个INSERT语句可能触发一个检查数据完整性的触发器。触发器通常由INSERT或UPDATE语句触发。 多版本并发控制：PostgreSQL使用多版本并发控制（MVCC，Multiversion concurrency control）系统进行并发控制，该系统向每个用户提供了一个数据库的”快照”，用户在事务内所作的每个修改，对于其他的用户都不可见，直到该事务成功提交。</p></li><li><p><strong>规则</strong>：规则（R·1LE）允许一个查询能被重写，通常用来实现对视图（VIEW）的操作，如插入（INSERT）、更新（UPDATE）、删除（DELETE）。</p></li><li><p><strong>数据类型</strong>：包括文本、任意精度的数值数组、JSON 数据、枚举类型、XML 数据</p><p>等。</p></li><li><p><strong>全文检索</strong>：通过 Tsearch2 或 OpenFTS，8.3版本中内嵌 Tsearch2。</p></li><li><p><strong>NoSQL</strong>：JSON，JSONB，XML，HStore 原生支持，至 NoSQL 数据库的外部数据包装器。</p></li><li><p><strong>*数据仓库</strong>：能平滑迁移至同属 PostgreSQL 生态的 GreenPlum，DeepGreen，HAWK 等，使用 FDW 进行 ETL。</p></li></ul><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>枚举类型、几何类型、网络地址类型、XML类型、JSON类型、数组类型、对象标识类型。。。</p><h4 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TYPE</span> mood <span class="keyword">AS</span> ENUM (<span class="string">'happy'</span>,<span class="string">'sad'</span>,<span class="string">'我太难了'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TYPE</span> <span class="keyword">week</span> <span class="keyword">AS</span> ENUM (<span class="string">'Mon'</span>,<span class="string">'Tue'</span>,<span class="string">'Wed'</span>,<span class="string">'Thu'</span>,<span class="string">'Fri'</span>,<span class="string">'Sat'</span>,<span class="string">'Sun'</span>,<span class="string">'996'</span>)</span><br></pre></td></tr></table></figure><h4 id="几何类型"><a href="#几何类型" class="headerlink" title="几何类型"></a>几何类型</h4><p><img src="C:%5CUsers%5C11240%5CDesktop%5C%E5%9B%BE%E8%A1%A8.png" alt="图表"></p><h4 id="JSON类型"><a href="#JSON类型" class="headerlink" title="JSON类型"></a>JSON类型</h4><ul><li><p>json 数据类型可以用来存储 JSON（JavaScript Object Notation）数据， 这样的数据也可以存储为 text，但是 json 数据类型更有利于检查每个存储的数值是可用的 JSON 值。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#作为JSON数组返回该数组</span></span><br><span class="line">array_to_json('&#123;&#123;1,5&#125;,&#123;99,100&#125;&#125;'::int[])         [[1,5],[99,100]]</span><br><span class="line"></span><br><span class="line"><span class="comment">#作为JSON对象返回行</span></span><br><span class="line">row_to_json(row(1,'foo'))&#123;"f1":1,"f2":"foo"&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> shop (</span><br><span class="line"><span class="keyword">name</span> <span class="built_in">text</span>,</span><br><span class="line">    good <span class="built_in">text</span>[],</span><br><span class="line">    price <span class="built_in">integer</span>[],</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> shop</span><br><span class="line">VALUSE (<span class="string">'五栋小卖部'</span>,</span><br><span class="line">    <span class="string">'&#123;"bread","beverage","snack"&#125;'</span>,</span><br><span class="line">    <span class="string">'&#123;3,5,10&#125;'</span>);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">UPDATE</span> shop <span class="keyword">SET</span> good = <span class="string">'&#123;"bread","beverage","snack","cup","slippers"&#125;'</span> <span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">'五栋小卖部'</span></span><br></pre></td></tr></table></figure><h4 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h4><p><img src="C:%5CUsers%5C11240%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1566550083876.png" alt="1566550083876"></p><h2 id="基本操作（从删库到跑路）"><a href="#基本操作（从删库到跑路）" class="headerlink" title="基本操作（从删库到跑路）"></a>基本操作（从删库到跑路）</h2><ul><li><p>创建数据库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> dbname;</span><br></pre></td></tr></table></figure></li><li><p>选择数据库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查询已经存在的数据库</span></span><br><span class="line">postgres=<span class="comment"># \l</span></span><br><span class="line"><span class="comment">#切换到指定数据库</span></span><br><span class="line">postgres=<span class="comment"># \c + dbname</span></span><br></pre></td></tr></table></figure></li><li><p>删除数据库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">DATABASE</span> [<span class="keyword">IF</span> EXITS ] dbname</span><br></pre></td></tr></table></figure></li><li><p>创建表格</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name(</span><br><span class="line">   column1 datatype,</span><br><span class="line">   column2 datatype,</span><br><span class="line">   column3 datatype,</span><br><span class="line">   .....</span><br><span class="line">   columnN datatype,</span><br><span class="line">   PRIMARY <span class="keyword">KEY</span>( 一个或多个列 )</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>删除表格</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line"><span class="comment">#查询所有表格</span></span><br><span class="line">postgres=<span class="comment"># \d</span></span><br></pre></td></tr></table></figure></li><li><p>增、删、改、查</p></li><li><p>当作对象数据库使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">String id;</span><br><span class="line">String title;</span><br><span class="line">List&lt;Author&gt; authors;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Author</span> </span>&#123;</span><br><span class="line">String id;</span><br><span class="line">String name;</span><br><span class="line">List&lt;Book&gt; books;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> book &#123;</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">character</span> <span class="built_in">varying</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">title <span class="built_in">character</span> <span class="built_in">varying</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="keyword">authors</span> <span class="built_in">character</span> <span class="built_in">varying</span>[] <span class="keyword">COMMENT</span> <span class="string">'ref: author.id'</span>,</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> author &#123;</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">character</span> <span class="built_in">varying</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line"><span class="keyword">name</span> <span class="built_in">character</span> <span class="built_in">varying</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">books <span class="built_in">character</span> <span class="built_in">varying</span>[] <span class="keyword">COMMENT</span> <span class="string">'ref: book.id'</span>,</span><br></pre></td></tr></table></figure></li></ul><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h4 id="模式（SCHEMA）"><a href="#模式（SCHEMA）" class="headerlink" title="模式（SCHEMA）"></a>模式（SCHEMA）</h4><p>PostgreSQL 模式（SCHEMA）可以看着是一个表的集合。一个模式可以包含视图、索引、数据类型、函数和操作符等。另外，可以使用带模式的完整名称来访问或者创建对象。</p><ul><li>允许多个用户使用一个数据库并且不会互相干扰。</li><li>将数据库对象组织成逻辑组以便更容易管理。</li><li>第三方应用的对象可以放在独立的模式中，这样它们就不会与其他对象的名称发生冲突。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建一个模式</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">SCHEMA</span> schema_name</span><br><span class="line"><span class="comment">#删除一个模式</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">SCHEMA</span> chema_name;</span><br><span class="line"><span class="comment">#删除一个模式以及其中包含的所有对象</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">SCHEMA</span> myschema_name <span class="keyword">CASCADE</span>;</span><br></pre></td></tr></table></figure><h4 id="视图（VIEW）"><a href="#视图（VIEW）" class="headerlink" title="视图（VIEW）"></a>视图（VIEW）</h4><p>视图是一个基于一个或多个表的数据定义的虚拟表。视图是没有数据的，视图里面的数据都是来自实际的表。</p><ul><li><p>用户或用户组认为更自然或直观查找结构数据的方式。</p></li><li><p>限制数据访问，用户只能看到有限的数据，而不是完整的表。</p></li><li><p>汇总各种表中的数据，用于生成报告。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [TEMP | <span class="keyword">TEMPORARY</span>] <span class="keyword">VIEW</span> view_name <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> column1, column2.....</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> [condition];</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> COMPANY;</span><br><span class="line"> id | name  | age | address   | salary</span><br><span class="line"><span class="comment">----+-------+-----+-----------+--------</span></span><br><span class="line">  1 | Paul  |  32 | California|  20000</span><br><span class="line">  2 | Allen |  25 | Texas     |  15000</span><br><span class="line">  3 | Teddy |  23 | Norway    |  20000</span><br><span class="line">  4 | Mark  |  25 | Rich-Mond |  65000</span><br><span class="line">  5 | David |  27 | Texas     |  85000</span><br><span class="line">  6 | Kim   |  22 | South-Hall|  45000</span><br><span class="line">  7 | James |  24 | Houston   |  10000</span><br><span class="line">(7 rows)</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> COMPANY_VIEW <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">ID</span>, <span class="keyword">NAME</span>, AGE</span><br><span class="line"><span class="keyword">FROM</span>  COMPANY;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> COMPANY_VIEW;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">id | name  | age</span><br><span class="line"><span class="comment">----+-------+-----</span></span><br><span class="line">  1 | Paul  |  32</span><br><span class="line">  2 | Allen |  25</span><br><span class="line">  3 | Teddy |  23</span><br><span class="line">  4 | Mark  |  25</span><br><span class="line">  5 | David |  27</span><br><span class="line">  6 | Kim   |  22</span><br><span class="line">  7 | James |  24</span><br><span class="line">(7 rows)</span><br></pre></td></tr></table></figure></li></ul><h4 id="继承（inheritance）"><a href="#继承（inheritance）" class="headerlink" title="继承（inheritance）"></a>继承（inheritance）</h4><p><strong>PostgreSQL</strong> 支持高级的 <strong>objdect-relational</strong> 机制，继承。继承允许一张表继承一张（或多张）表的列属性，来建立 <strong>parent-child</strong>关系。子表可以继承父表的字段以及约束，同时可以拥有自己的字段。</p><p>当执行一个父表查询的时候，这个查询可以获取来自本表和它的子表，也可以指定只查询本表。在子表中查询，则不会返回父表的数据。</p><ul><li>让我们从一个例子开始：假设我们试图制作一个城市数据模型。每个省都有许多城市，但是只有一个省会。我们希望能够迅速检索任何一个省的省会。这个任务可以通过创建两个表来实现，一个是省会表，一个是非省会表。不过，如果我们不管什么城市都想查该怎么办?继承的特性可以帮助我们解决这个问题。我们定义 <code>capitals</code> 表，它继承自 <code>cities</code> 表：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> cities (</span><br><span class="line">    <span class="keyword">name</span>            <span class="built_in">text</span>,</span><br><span class="line">    population      <span class="built_in">float</span>,</span><br><span class="line">    altitude        <span class="built_in">int</span>     <span class="comment">-- 英尺</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> capitals (</span><br><span class="line">    state           <span class="built_in">char</span>(<span class="number">2</span>)</span><br><span class="line">) INHERITS (cities);</span><br></pre></td></tr></table></figure><p><strong>注：</strong>在 PostgreSQL 里，一个表可以从零个或多个其它表中继承属性</p><ul><li><strong>ONLY</strong>关键字</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span>, altitude</span><br><span class="line">    <span class="keyword">FROM</span> cities</span><br><span class="line">    <span class="keyword">WHERE</span> altitude &gt; <span class="number">500</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   name    | altitude</span><br><span class="line"><span class="comment">-----------+----------</span></span><br><span class="line"> Rikaze    |     4000</span><br><span class="line"> Lasa      | 3658</span><br><span class="line"> Kunming   |     1891.4</span><br><span class="line"> Chengdu   |     505.9</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span>, altitude</span><br><span class="line">    <span class="keyword">FROM</span> <span class="keyword">ONLY</span> cities</span><br><span class="line">    <span class="keyword">WHERE</span> altitude &gt; <span class="number">500</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-----------+----------</span></span><br><span class="line"> Rikaze    |     4000</span><br></pre></td></tr></table></figure><p><strong>注：</strong><code>cities</code> 前面的 <code>ONLY</code> 表明该查询应该只针对 <code>cities</code> 而不包括其后代。许多我们已经讨论过的命令(<code>SELECT</code>, <code>UPDATE</code>, <code>DELETE</code>)都支持 <code>ONLY</code> 关键字</p><ul><li><p>有时候你可能想知道某个行版本来自哪个表。在每个表里我们都有一个 <code>tableoid</code> 系统属性可以告诉你源表是谁：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> c.tableoid, c.name, c.altitude</span><br><span class="line"><span class="keyword">FROM</span> cities c</span><br><span class="line"><span class="keyword">WHERE</span> c.altitude &gt; <span class="number">500</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> tableoid |   name    | altitude</span><br><span class="line"><span class="comment">----------+-----------+----------</span></span><br><span class="line">   139793 |  Rikaze    |     4000</span><br><span class="line">   139793 | Lasa      | 3658</span><br><span class="line">   139798 | Kunming   |     1891.4</span><br><span class="line">   139797 | Chengdu   |     505.9</span><br></pre></td></tr></table></figure></li></ul><h2 id="聊聊PostgreSQL"><a href="#聊聊PostgreSQL" class="headerlink" title="聊聊PostgreSQL"></a>聊聊PostgreSQL</h2><ul><li>PostgreSQL这么强大，为什么在国内其流行度远不如MySQL？<ol><li>中国第一次互联网浪潮的时候（2000年左右），PostgreSQL在性能、易用性和对Windows的支持远远不如MySQL，所以尽管现在的PostgreSQL或许比MySQL好，但已经错失了一个重要的时机，想要代替MySQL需要很大努力。</li><li>现在使用MySQL的人非常多，社区也比PostgreSQL成熟，其遇到的问题也基本有解。而PostgreSQL没有高水平的团队的话一般不会轻易尝试。</li></ol></li></ul><h2 id="可视化工具"><a href="#可视化工具" class="headerlink" title="可视化工具"></a>可视化工具</h2><ul><li><p>Navicat</p></li><li><p>Mysql Workbench</p><p><strong>MySQL Workbench</strong>是一个可视化<a href="https://en.wikipedia.org/wiki/Database_design" target="_blank" rel="noopener">数据库设计</a>工具，它将<a href="https://en.wikipedia.org/wiki/SQL" target="_blank" rel="noopener">SQL </a><a href="https://en.wikipedia.org/wiki/Software_development" target="_blank" rel="noopener">开发</a>，<a href="https://en.wikipedia.org/wiki/Database_administration" target="_blank" rel="noopener">管理</a>，<a href="https://en.wikipedia.org/wiki/Database_design" target="_blank" rel="noopener">数据库设计</a>，创建和维护<a href="https://en.wikipedia.org/wiki/Integrated_development_environment" target="_blank" rel="noopener">集成</a>到<a href="https://en.wikipedia.org/wiki/MySQL" target="_blank" rel="noopener">MySQL</a>数据库系统的单一<a href="https://en.wikipedia.org/wiki/Integrated_development_environment" target="_blank" rel="noopener">集成开发环境</a>中。它是fabFORCE.net的DBDesigner 4的继承者，取代了以前的软件包<a href="https://en.wikipedia.org/wiki/MySQL_Workbench#MySQL_GUI_Tools_Bundle" target="_blank" rel="noopener">MySQL GUI Tools Bundle</a>。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;PostgreSQL&quot;&gt;&lt;a href=&quot;#PostgreSQL&quot; class=&quot;headerlink&quot; title=&quot;PostgreSQL&quot;&gt;&lt;/a&gt;PostgreSQL&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;PostgreSQL 不寻常的名字导致一些读者停下
      
    
    </summary>
    
    
      <category term="mysql" scheme="http://solamish.github.io/categories/mysql/"/>
    
    
      <category term="后端" scheme="http://solamish.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="mysql" scheme="http://solamish.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>高性能MySQL第一章笔记</title>
    <link href="http://solamish.github.io/2019/11/03/%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E7%AC%AC%E4%B8%80%E7%AB%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://solamish.github.io/2019/11/03/高性能MySQL第一章笔记/</id>
    <published>2019-11-02T16:51:38.000Z</published>
    <updated>2019-11-02T16:52:47.141Z</updated>
    
    <content type="html"><![CDATA[<h2 id="高性能MySQL"><a href="#高性能MySQL" class="headerlink" title="高性能MySQL"></a>高性能MySQL</h2><h3 id="逻辑架构"><a href="#逻辑架构" class="headerlink" title="逻辑架构"></a>逻辑架构</h3><p><img src="https://pic002.cnblogs.com/images/2012/152332/2012031510324452.png" alt="逻辑架构">·</p><ul><li>第一层： 连接处理，授权认证</li><li>第二层： MySQL的核心部分（查询、解析、优化、缓存），实现存储过程、视图、触发器。</li><li>第三层：存储引擎层，主要负责数据的存储和提取。<em>注：存储引擎不会去解析SQL</em></li></ul><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><ul><li>在MySQL中一个连接对应一个线程，每个连接的查询只会单独在单独的线程中进行，而线程只会轮流在某个CPU核心或者CPU中运行。</li></ul><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><ul><li><p>MySQL 会解析查询，并创建内部的数据结构（解析树），然后对其进行优化，包括重写查询，决定表的读取顺序，以及选择合适的索引。用户可以使用特殊关键字提示优化器，影响他的决策。</p></li><li><p>优化器不关心使用的存储引擎，但存储引擎会对优化查询有影响。</p></li><li><p>对于SELECT语句，在解析查询前，服务器会先检查缓存，如果能找到对应的查询，服务器将不必再执行解析，优化和执行的整个过程。</p></li></ul><h3 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h3><ul><li>只要多个查询在同一时刻修改数据，就会产生并发控制的问题。</li><li>MySQL主要从服务器层和存储引擎两个层面处理并发控制。</li></ul><h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><ul><li>对于一个邮箱读取操作，即使同一时刻有多个用户并发读取也不会有什么问题，但如果某个用户正在再读取邮箱，同时另外一个用户试图删除此邮件，那可能就会产生意料之外的结果。所以，即使读取操作，也需要注意。</li><li>解决这类问题的办法就是并发控制。其实就是在处理并发读或者写的时候，通过实现一个由两种类型的锁组成的锁系统来解决问题。这两种类型的锁一般称为共享锁和排他锁，也叫读锁和写锁。</li><li>读锁是共享的，或者说相互不阻塞。多个客户在同一时刻可以同时读取同一资源，互不干扰。</li><li>写锁是排他的，也就是说一个写锁会阻塞其他的写锁和读锁。</li></ul><h3 id="锁粒度"><a href="#锁粒度" class="headerlink" title="锁粒度"></a>锁粒度</h3><ul><li>一种提高共享资源并发性的方式就是让锁对象更具有选择性。锁定的数据量越少，系统的并发程度就越高。</li><li>加锁需要消耗资源吗。锁的各种操作，包括获取锁，检查锁是否已经解除，释放锁都会增加系统的开销。</li><li>所谓锁策略，就是在锁的开销和数据的安全性之间寻求平衡。</li><li>而MySQL提供了多种选择，每种MySQL引擎都可以实现自己的所策略和锁粒度</li></ul><h4 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h4><ul><li>表锁是开销最小的锁策略：它会锁定整张表，一个用户在对表进行写操作前，需要先获得写锁，这会阻塞其他用户对该表的读写操作。只有当写锁不存在的时候，其他用户才能获取读锁。</li><li>服务器在使用ALTER TABLE时会使用表锁，而忽略存储引擎的锁机制。</li></ul><h4 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h4><ul><li>行级锁可以最大程度地支持并发处理（但同时也带来了最大的锁开销）。在InnoDB和XtraDB，以及一些其它存储引擎实现了行级锁。行级锁只在存储引擎层实现，而MySQL服务器层没有实现。</li></ul><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><ul><li>事务是数据库执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成。<h4 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h4></li><li>原子性：事务中的所有操作被作为一个整体执行，要么全部执行，要么全部不执行（不能只执行其中一部分）</li><li>一致性： 数据库总是从一个一致性的状态转换到另外一个一致性的状态。一致状态是指数据库状态应满足完整性约束。</li><li>隔离性：一个事务所做的修改在最终提交以前，对其他事务是不可见的。（即一个事务不会影响另一个事务的执行）</li><li>持久性：事务一旦提交，就会被永久的保存到数据库中，即使系统崩溃，修改的数据也不会丢失。</li><li>就像锁粒度升级会增加系统开销一样，实现了ACID的数据库相对于没有实现ACID的数据，所需要的CPU、内存、磁盘空间更大。</li></ul><h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><ul><li><p>未提交读（<strong>READ UNCOMMITED</strong>)：事务中的修改，即使没有提交，对其他事务也是可见的。（这种情况容易造成脏读<br><em>脏读又称无效数据的读出，是指在数据库访问中，事务T1将某一值修改，然后事务T2读取该值，此后T1因为某种原因撤销对该值的修改，这就导致了T2所读取到的数据是无效的。</em></p></li><li><p>提交读(<strong>READ COMMITED</strong>)：大多数数据库默认隔离级别都是提交读（MySQL是可重复读）。所谓提交读，就是指一个事务从开始直到提交前，所做的任何操作修改对其他事务都是不可见的。</p></li><li><p>可重复读(<strong>REPETABLE READ</strong>)：可重复度解决了脏读的问题，但还是没办法解决幻读。所谓幻读，指的是当事务A在某个范围进行查询操作时，事务B又在该范围执行了<strong>Insert</strong>或<strong>Delete</strong>操作，当事务A再次读取该范围的记录时，会得到两个不一样的数据。</p></li><li><p>可串行化(<strong>SERIALIZABLE</strong>)：可窜行化会在读取的每一行的数据上都加锁，所以可能会导致大量的超时和锁争用的问题。（只有在非常需要确保数据的一致性而且可以接受没有并发的情况下，才考虑采用该级别。）</p></li><li><p>MySQL默认采用自动提交模式。如果不是显式地开始一个事务，则每个查询都被当作一个事务执行提交操作。另外，在执行ALTER TABEL命令时，会强制执行COMMIT操作。</p></li></ul><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><ul><li>死锁是指两个或者多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致二型循环的现象。</li></ul><h3 id="多版本并发控制（MVCC）"><a href="#多版本并发控制（MVCC）" class="headerlink" title="多版本并发控制（MVCC）"></a>多版本并发控制（MVCC）</h3><ul><li>MySQL 的大多数事务性存储引擎实现的都不是简单的行级锁。基于提升并发性能的考虑，它们一般同时实现了多版本并发控制。</li><li>可以认为MVCC是行级锁的一个变种，但是它在很多情况下避免了加锁的操作。</li><li>不同存储引擎的MVCC实现是不同的，对于InnoDB，是通过在每行的记录后面保存两个隐藏的列实现的。这个两个列，一个保存了行的创建时间，一个保存了行的过期时间。（这里的时间不是指实际的时间，而是指系统的版本号。）<h4 id="可重复读的具体实现如下"><a href="#可重复读的具体实现如下" class="headerlink" title="可重复读的具体实现如下:"></a>可重复读的具体实现如下:</h4><h5 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h5>a.InnoDB 只查找版本早于当前事务的数据行。这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是已经修改完成的。<br>b.行的删除版本要么未定义，要么大于当前事务版本号。这可以确保事务读取到的行，在事务开始之前未被删除。</li></ul><h5 id="INSERT"><a href="#INSERT" class="headerlink" title="INSERT"></a>INSERT</h5><pre><code>InnoDB为新插入的每一行保存当前系统版本号作为行版本号。</code></pre><h5 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h5><pre><code>InnoDB为删除的每一行保存当前系统版本号作为删除标识。</code></pre><h5 id="UPDATE"><a href="#UPDATE" class="headerlink" title="UPDATE"></a>UPDATE</h5><pre><code>InnoDB为插入一行新纪录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为删除标识符。</code></pre><p>保存这两个额外系统版本号， 使大多数操作都可以不用加锁。这样操作使得读数据操作很简单，性能很好，并且能保证只会读取到符合标准的行。不足之处是每行纪录都需要额外的存储空间，需要做更多的行检查工作，以及一些额外的维护工作。</p><p>MVCC只在可重复读和只读两个隔离级别下工作。其他两个隔离级别都与MVCC不兼容。</p><h3 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h3><h4 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h4><ul><li><p>InnoDB采用MVCC支持高并发，并且实现了四个标准的隔离级别。其默认级别是可重复读，并且通过<strong>间隙锁</strong>策略防止幻读的出现。</p></li><li><p>InnoDB是基于聚簇索引建立的，聚簇索引对逐渐查询有很高的性能，但它的二级索引中必须包含主键列，所以如果主键列很打的话，其他的所有索引都会很大。</p></li><li><p>InnoDB支持索引，外键，并采用了行级锁。</p></li></ul><h4 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h4><ul><li>MyISAM相对于InnoDB的一个缺陷就是崩溃后无法安全恢复</li><li>MyISAM会<strong>对整张表加锁</strong>，而不是采用行级锁</li><li>MyISAM支持全文索引，也可以使用mysiampack对MyISAM表进行压缩。（压缩之后的表不能进行修改，压缩表可以极大地减少磁盘空间占用）</li></ul><h3 id="转换表的引擎"><a href="#转换表的引擎" class="headerlink" title="转换表的引擎"></a>转换表的引擎</h3><p>1.ALTER TABLE</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE mytable ENGINE = InnoDB;</span><br></pre></td></tr></table></figure><p>该方法需要执行很长时间，在复制期间可能会消耗系统所有的I/O能力，同时原表上会加上读锁。</p><p>2.通过mysqldump工具将数据库文件导出，然后修改文件中CREATE TABLE 中的存储引擎选项，同时注意修改表名。</p><p>3.创建与查询</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE innodb_table like mysiam_table</span><br><span class="line">ALTER TABLE innodb_table engine = InnoDB</span><br><span class="line">INSERT INTO innodb_table select * from myisam_table</span><br></pre></td></tr></table></figure><p>如果数据量过大的话，则可以考虑做分批处理，针对每一段数据执行事务提交数据操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">STARAT TRANSACTION;</span><br><span class="line">INSERT INIO innodb_table select * from mysiam_table WHERE id BETWEEN x and y;</span><br><span class="line">COMMIT;</span><br></pre></td></tr></table></figure><h3 id="选择合适的引擎"><a href="#选择合适的引擎" class="headerlink" title="选择合适的引擎"></a>选择合适的引擎</h3><ul><li><p>“除非需要用到某些InnoDB 不具备的特性，并且没有其他办法可以替代，否则都应该InnoDB引擎”。</p></li><li><p>如果要使用全文索引，优先考虑InnoDB加上Sphinx组合，而不是使用支持全文索引的MyISAM。</p></li><li><p>如果不是万不得已，否则建议不要混合使用存储引擎。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;高性能MySQL&quot;&gt;&lt;a href=&quot;#高性能MySQL&quot; class=&quot;headerlink&quot; title=&quot;高性能MySQL&quot;&gt;&lt;/a&gt;高性能MySQL&lt;/h2&gt;&lt;h3 id=&quot;逻辑架构&quot;&gt;&lt;a href=&quot;#逻辑架构&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
    
      <category term="mysql" scheme="http://solamish.github.io/categories/mysql/"/>
    
    
      <category term="后端" scheme="http://solamish.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="mysql" scheme="http://solamish.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Channel</title>
    <link href="http://solamish.github.io/2019/11/02/Channel/"/>
    <id>http://solamish.github.io/2019/11/02/Channel/</id>
    <published>2019-11-02T15:10:38.000Z</published>
    <updated>2019-11-02T15:15:23.593Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><h3 id="Channel的基本语法"><a href="#Channel的基本语法" class="headerlink" title="Channel的基本语法"></a>Channel的基本语法</h3><p>如果说goroutine是Go语言程序的并发体的话，那么channels则是它们之间的通信机制。使用channel，我们可以在两个goroutine之间通信（传输数据）。</p><p>使用内置的make函数，我们可以创建一个channel：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>) <span class="comment">// ch的数据类型是chan int</span></span><br></pre></td></tr></table></figure><p>一个channel有发送和接受两个主要操作。发送和接收两个操作都使用<code>&lt;-</code>运算符。在发送语句中，<code>&lt;-</code>运算符分割channel和要发送的值。在接收语句中，<code>&lt;-</code>运算符写在channel对象之前。一个不使用接收结果的接收操作也是合法的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ch &lt;- x  <span class="comment">// 将变量x发送给管道ch</span></span><br><span class="line">x = &lt;-ch <span class="comment">// 变量x接受管道ch发送过来的值</span></span><br><span class="line">&lt;-ch     <span class="comment">// 接受管道ch发送过来的值，但不使用</span></span><br></pre></td></tr></table></figure><h4 id="不带缓存的channel"><a href="#不带缓存的channel" class="headerlink" title="不带缓存的channel"></a>不带缓存的channel</h4><p>一个基于无缓存Channels的发送操作将导致发送者goroutine阻塞，直到另一个goroutine在相同的Channels上执行接收操作，当发送的值通过Channels成功传输之后，两个goroutine可以继续执行后面的语句。反之，如果接收操作先发生，那么接收者goroutine也将阻塞，直到有另一个goroutine在相同的Channels上执行发送操作。</p><p>不带缓存的channel的声明方式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch = <span class="built_in">make</span>(<span class="keyword">chan</span> T) <span class="comment">//可以接收和发送类型为 T 的数据</span></span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ch <span class="keyword">chan</span> T  <span class="comment">// 可以接收和发送类型为 T 的数据</span></span><br></pre></td></tr></table></figure><p>我们来看一个栗子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> channel = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">var</span> send = <span class="number">6666</span></span><br><span class="line">    <span class="comment">// 关键字go后跟的是需要被并发执行的代码块，它由一个匿名函数代表</span></span><br><span class="line">    <span class="comment">// 在这里，我们只要知道在花括号中的就是将要被并发执行的代码就可以</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">channel &lt;- send</span><br><span class="line">fmt.Println(<span class="string">"数据已发送"</span>)</span><br><span class="line">&#125;()</span><br><span class="line">    <span class="comment">// 这里让主线程休眠1秒钟</span></span><br><span class="line">    <span class="comment">// 以使上面的goroutine有机会被执行</span></span><br><span class="line">    time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行上述代码后，我们发现控制台并没有输出“数据已发送”这几个字样。这是因为我们只向channel传递了sent的值，而没有从channel中取出，从而导致当前goroutine被阻塞，也就是Println这条语句没有被执行。</p><p>为此我们稍作改进:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> channel = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">var</span> send = <span class="number">6666</span></span><br><span class="line"><span class="keyword">var</span> receive <span class="keyword">int</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 向channel中传递sent的值</span></span><br><span class="line">channel &lt;- send</span><br><span class="line">fmt.Println(<span class="string">"数据已发送"</span>)</span><br><span class="line">&#125;()</span><br><span class="line">    <span class="comment">// 使用receive接受从channel中传来的值</span></span><br><span class="line">receive = &lt;- channel</span><br><span class="line">fmt.Println(receive)</span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">数据已发送</span><br><span class="line"><span class="number">6666</span></span><br></pre></td></tr></table></figure><p>我们成功地接受到了channel中的值，并解决了goroutine的阻塞问题。（只有channel的接收者，也会导致当前goroutine的阻塞，感兴趣的同学可以自己模拟实现下）</p><h3 id="带缓存的Channel"><a href="#带缓存的Channel" class="headerlink" title="带缓存的Channel"></a>带缓存的Channel</h3><p>带缓存的Channel内部持有一个元素队列。队列的最大容量是在调用make函数创建channel时通过第二个参数指定的。下面的语句创建了一个可以持有三个字符串元素的带缓存Channel。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>我们可以在无阻塞的情况下连续向新创建的channel发送三个值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ch &lt;- <span class="string">"A"</span></span><br><span class="line">ch &lt;- <span class="string">"B"</span></span><br><span class="line">ch &lt;- <span class="string">"C"</span></span><br></pre></td></tr></table></figure><p>但当我们发送第四个数据的时候，就会造成当前goroutine的阻塞</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 声明了一个带有3个缓存空间的channel</span></span><br><span class="line"><span class="keyword">var</span> channel = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">channel &lt;- <span class="string">"A"</span></span><br><span class="line">channel &lt;- <span class="string">"B"</span></span><br><span class="line">channel &lt;- <span class="string">"C"</span></span><br><span class="line">fmt.Println(<span class="string">"我发送了3个数据"</span>)</span><br><span class="line">        <span class="comment">// 当发送第四个值的时候，goroutine阻塞</span></span><br><span class="line">channel &lt;- <span class="string">"D"</span></span><br><span class="line">fmt.Println(<span class="string">"我发送了第4个数据"</span>)</span><br><span class="line">&#125;()</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我发送了3个数据</span><br></pre></td></tr></table></figure><h3 id="Range-amp-Close"><a href="#Range-amp-Close" class="headerlink" title="Range&amp;Close"></a>Range&amp;Close</h3><p><code>for value:=range ch</code>操作可以说是非常熟悉了，当我们遍历slice或者map时也是同样的用法</p><p><code>close</code>也就是golang的内置函数，可以用于关闭一个channel</p><p>对一个已经被close过的channel进行接收操作依然可以接受到之前已经成功发送的数据</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(n <span class="keyword">int</span>, c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">x, y := <span class="number">1</span>, <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">c &lt;- x</span><br><span class="line">x, y = y, x + y <span class="comment">//交换变量的便利写法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(c) <span class="comment">//关闭通道</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">go</span> fibonacci(<span class="built_in">cap</span>(c), c) <span class="comment">//cap(c)即为c的容量大小</span></span><br><span class="line">    <span class="comment">// 不断读取channel数据，直到channel被显式关闭</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> c &#123; </span><br><span class="line">fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>记住应该在生产者的地方关闭channel，而不是消费的地方去关闭它，这样容易引起panic。</p><p>另外，关闭一个已经被关闭的channel也将导致panic。</p><h3 id="单方向的Channel"><a href="#单方向的Channel" class="headerlink" title="单方向的Channel"></a>单方向的Channel</h3><p>前面我们提到，channel具有接受和发送两种操作，但如果我们只想要一个具有发送功能的channel应该怎么办呢？</p><p>Go语言的类型系统提供了单方向的channel类型，分别用于只发送或只接收的channel。</p><p>类型<code>chan&lt;- int</code>表示一个只发送int的channel，只能发送不能接收。相反，类型<code>&lt;-chan int</code>表示一个只接收int的channel，只能接收不能发送。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">send := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">go</span> counter(send)</span><br><span class="line">squarer(send)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">counter</span><span class="params">(out <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> x := <span class="number">0</span>; x &lt; <span class="number">100</span>; x++ &#123;</span><br><span class="line">out &lt;- x</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(out)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">squarer</span><span class="params">(in &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> v := <span class="keyword">range</span> in &#123;</span><br><span class="line">fmt.Println(v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通道死锁"><a href="#通道死锁" class="headerlink" title="通道死锁"></a>通道死锁</h3><p>通道两段互相阻塞对方，会形成死锁状态。Go运行时会检查并panic，停止程序。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">out := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">out &lt;- <span class="number">2</span></span><br><span class="line"><span class="keyword">go</span> f1(out)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f1</span><span class="params">(in <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(&lt;-in)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fatal error: all goroutines are asleep - deadlock!</span><br></pre></td></tr></table></figure><p>显然在<code>out &lt;- 2</code>的时候，由于没有接受者，主线程被阻塞。</p><h2 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h2><p><code>select</code> 是一种与 <code>switch</code> 非常相似的控制结构，与 <code>switch</code> 不同的是，<code>select</code> 中虽然也有多个 <code>case</code>，但是这些 <code>case</code> 中的表达式都必须与 Channel的操作有关，也就是 Channel 的读写操作，下面的函数就展示了一个包含从 Channel 中读取数据和向 Channel 发送数据的 <code>select</code> 结构：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(ch, quit <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">x, y := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> ch &lt;- x:</span><br><span class="line">x, y = y, x+y</span><br><span class="line"><span class="keyword">case</span> &lt;-quit:</span><br><span class="line">fmt.Println(<span class="string">"quit"</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span> )</span><br><span class="line">quit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span> ; i++ &#123;</span><br><span class="line"><span class="comment">// 接受通道c传来的值，并打印到控制台</span></span><br><span class="line">fmt.Println(&lt;-c)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当协程执行完上述操作后，向quit发送数据</span></span><br><span class="line">quit &lt;- <span class="number">0</span></span><br><span class="line">&#125;()</span><br><span class="line">fibonacci(c, quit)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这里，我们可能会疑惑，如果同时有多个case需要处理，那怎么办？</p><p>如果多个case同时就绪时，select会随机地选择一个执行，这样来保证每一个channel都有平等的被select的机会</p><p>如果没有case需要处理，则会选择<code>default</code>去处理，若没有<code>default</code>语句时则<code>select</code>语句会被阻塞（<code>select</code>默认为阻塞），直到某个case需要处理</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Channel&quot;&gt;&lt;a href=&quot;#Channel&quot; class=&quot;headerlink&quot; title=&quot;Channel&quot;&gt;&lt;/a&gt;Channel&lt;/h2&gt;&lt;h3 id=&quot;Channel的基本语法&quot;&gt;&lt;a href=&quot;#Channel的基本语法&quot; class=&quot;
      
    
    </summary>
    
    
      <category term="golang基础语法" scheme="http://solamish.github.io/categories/golang%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    
    
      <category term="后端" scheme="http://solamish.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Golang" scheme="http://solamish.github.io/tags/Golang/"/>
    
  </entry>
  
</feed>
