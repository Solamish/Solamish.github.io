<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>个人博客</title>
  
  <subtitle>Solamish的博客小站</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://solamish.github.io/"/>
  <updated>2019-11-02T16:52:47.141Z</updated>
  <id>http://solamish.github.io/</id>
  
  <author>
    <name>Solamish</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>高性能MySQL第一章笔记</title>
    <link href="http://solamish.github.io/2019/11/03/%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E7%AC%AC%E4%B8%80%E7%AB%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://solamish.github.io/2019/11/03/高性能MySQL第一章笔记/</id>
    <published>2019-11-02T16:51:38.000Z</published>
    <updated>2019-11-02T16:52:47.141Z</updated>
    
    <content type="html"><![CDATA[<h2 id="高性能MySQL"><a href="#高性能MySQL" class="headerlink" title="高性能MySQL"></a>高性能MySQL</h2><h3 id="逻辑架构"><a href="#逻辑架构" class="headerlink" title="逻辑架构"></a>逻辑架构</h3><p><img src="https://pic002.cnblogs.com/images/2012/152332/2012031510324452.png" alt="逻辑架构">·</p><ul><li>第一层： 连接处理，授权认证</li><li>第二层： MySQL的核心部分（查询、解析、优化、缓存），实现存储过程、视图、触发器。</li><li>第三层：存储引擎层，主要负责数据的存储和提取。<em>注：存储引擎不会去解析SQL</em></li></ul><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><ul><li>在MySQL中一个连接对应一个线程，每个连接的查询只会单独在单独的线程中进行，而线程只会轮流在某个CPU核心或者CPU中运行。</li></ul><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><ul><li><p>MySQL 会解析查询，并创建内部的数据结构（解析树），然后对其进行优化，包括重写查询，决定表的读取顺序，以及选择合适的索引。用户可以使用特殊关键字提示优化器，影响他的决策。</p></li><li><p>优化器不关心使用的存储引擎，但存储引擎会对优化查询有影响。</p></li><li><p>对于SELECT语句，在解析查询前，服务器会先检查缓存，如果能找到对应的查询，服务器将不必再执行解析，优化和执行的整个过程。</p></li></ul><h3 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h3><ul><li>只要多个查询在同一时刻修改数据，就会产生并发控制的问题。</li><li>MySQL主要从服务器层和存储引擎两个层面处理并发控制。</li></ul><h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><ul><li>对于一个邮箱读取操作，即使同一时刻有多个用户并发读取也不会有什么问题，但如果某个用户正在再读取邮箱，同时另外一个用户试图删除此邮件，那可能就会产生意料之外的结果。所以，即使读取操作，也需要注意。</li><li>解决这类问题的办法就是并发控制。其实就是在处理并发读或者写的时候，通过实现一个由两种类型的锁组成的锁系统来解决问题。这两种类型的锁一般称为共享锁和排他锁，也叫读锁和写锁。</li><li>读锁是共享的，或者说相互不阻塞。多个客户在同一时刻可以同时读取同一资源，互不干扰。</li><li>写锁是排他的，也就是说一个写锁会阻塞其他的写锁和读锁。</li></ul><h3 id="锁粒度"><a href="#锁粒度" class="headerlink" title="锁粒度"></a>锁粒度</h3><ul><li>一种提高共享资源并发性的方式就是让锁对象更具有选择性。锁定的数据量越少，系统的并发程度就越高。</li><li>加锁需要消耗资源吗。锁的各种操作，包括获取锁，检查锁是否已经解除，释放锁都会增加系统的开销。</li><li>所谓锁策略，就是在锁的开销和数据的安全性之间寻求平衡。</li><li>而MySQL提供了多种选择，每种MySQL引擎都可以实现自己的所策略和锁粒度</li></ul><h4 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h4><ul><li>表锁是开销最小的锁策略：它会锁定整张表，一个用户在对表进行写操作前，需要先获得写锁，这会阻塞其他用户对该表的读写操作。只有当写锁不存在的时候，其他用户才能获取读锁。</li><li>服务器在使用ALTER TABLE时会使用表锁，而忽略存储引擎的锁机制。</li></ul><h4 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h4><ul><li>行级锁可以最大程度地支持并发处理（但同时也带来了最大的锁开销）。在InnoDB和XtraDB，以及一些其它存储引擎实现了行级锁。行级锁只在存储引擎层实现，而MySQL服务器层没有实现。</li></ul><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><ul><li>事务是数据库执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成。<h4 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h4></li><li>原子性：事务中的所有操作被作为一个整体执行，要么全部执行，要么全部不执行（不能只执行其中一部分）</li><li>一致性： 数据库总是从一个一致性的状态转换到另外一个一致性的状态。一致状态是指数据库状态应满足完整性约束。</li><li>隔离性：一个事务所做的修改在最终提交以前，对其他事务是不可见的。（即一个事务不会影响另一个事务的执行）</li><li>持久性：事务一旦提交，就会被永久的保存到数据库中，即使系统崩溃，修改的数据也不会丢失。</li><li>就像锁粒度升级会增加系统开销一样，实现了ACID的数据库相对于没有实现ACID的数据，所需要的CPU、内存、磁盘空间更大。</li></ul><h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><ul><li><p>未提交读（<strong>READ UNCOMMITED</strong>)：事务中的修改，即使没有提交，对其他事务也是可见的。（这种情况容易造成脏读<br><em>脏读又称无效数据的读出，是指在数据库访问中，事务T1将某一值修改，然后事务T2读取该值，此后T1因为某种原因撤销对该值的修改，这就导致了T2所读取到的数据是无效的。</em></p></li><li><p>提交读(<strong>READ COMMITED</strong>)：大多数数据库默认隔离级别都是提交读（MySQL是可重复读）。所谓提交读，就是指一个事务从开始直到提交前，所做的任何操作修改对其他事务都是不可见的。</p></li><li><p>可重复读(<strong>REPETABLE READ</strong>)：可重复度解决了脏读的问题，但还是没办法解决幻读。所谓幻读，指的是当事务A在某个范围进行查询操作时，事务B又在该范围执行了<strong>Insert</strong>或<strong>Delete</strong>操作，当事务A再次读取该范围的记录时，会得到两个不一样的数据。</p></li><li><p>可串行化(<strong>SERIALIZABLE</strong>)：可窜行化会在读取的每一行的数据上都加锁，所以可能会导致大量的超时和锁争用的问题。（只有在非常需要确保数据的一致性而且可以接受没有并发的情况下，才考虑采用该级别。）</p></li><li><p>MySQL默认采用自动提交模式。如果不是显式地开始一个事务，则每个查询都被当作一个事务执行提交操作。另外，在执行ALTER TABEL命令时，会强制执行COMMIT操作。</p></li></ul><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><ul><li>死锁是指两个或者多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致二型循环的现象。</li></ul><h3 id="多版本并发控制（MVCC）"><a href="#多版本并发控制（MVCC）" class="headerlink" title="多版本并发控制（MVCC）"></a>多版本并发控制（MVCC）</h3><ul><li>MySQL 的大多数事务性存储引擎实现的都不是简单的行级锁。基于提升并发性能的考虑，它们一般同时实现了多版本并发控制。</li><li>可以认为MVCC是行级锁的一个变种，但是它在很多情况下避免了加锁的操作。</li><li>不同存储引擎的MVCC实现是不同的，对于InnoDB，是通过在每行的记录后面保存两个隐藏的列实现的。这个两个列，一个保存了行的创建时间，一个保存了行的过期时间。（这里的时间不是指实际的时间，而是指系统的版本号。）<h4 id="可重复读的具体实现如下"><a href="#可重复读的具体实现如下" class="headerlink" title="可重复读的具体实现如下:"></a>可重复读的具体实现如下:</h4><h5 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h5>a.InnoDB 只查找版本早于当前事务的数据行。这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是已经修改完成的。<br>b.行的删除版本要么未定义，要么大于当前事务版本号。这可以确保事务读取到的行，在事务开始之前未被删除。</li></ul><h5 id="INSERT"><a href="#INSERT" class="headerlink" title="INSERT"></a>INSERT</h5><pre><code>InnoDB为新插入的每一行保存当前系统版本号作为行版本号。</code></pre><h5 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h5><pre><code>InnoDB为删除的每一行保存当前系统版本号作为删除标识。</code></pre><h5 id="UPDATE"><a href="#UPDATE" class="headerlink" title="UPDATE"></a>UPDATE</h5><pre><code>InnoDB为插入一行新纪录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为删除标识符。</code></pre><p>保存这两个额外系统版本号， 使大多数操作都可以不用加锁。这样操作使得读数据操作很简单，性能很好，并且能保证只会读取到符合标准的行。不足之处是每行纪录都需要额外的存储空间，需要做更多的行检查工作，以及一些额外的维护工作。</p><p>MVCC只在可重复读和只读两个隔离级别下工作。其他两个隔离级别都与MVCC不兼容。</p><h3 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h3><h4 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h4><ul><li><p>InnoDB采用MVCC支持高并发，并且实现了四个标准的隔离级别。其默认级别是可重复读，并且通过<strong>间隙锁</strong>策略防止幻读的出现。</p></li><li><p>InnoDB是基于聚簇索引建立的，聚簇索引对逐渐查询有很高的性能，但它的二级索引中必须包含主键列，所以如果主键列很打的话，其他的所有索引都会很大。</p></li><li><p>InnoDB支持索引，外键，并采用了行级锁。</p></li></ul><h4 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h4><ul><li>MyISAM相对于InnoDB的一个缺陷就是崩溃后无法安全恢复</li><li>MyISAM会<strong>对整张表加锁</strong>，而不是采用行级锁</li><li>MyISAM支持全文索引，也可以使用mysiampack对MyISAM表进行压缩。（压缩之后的表不能进行修改，压缩表可以极大地减少磁盘空间占用）</li></ul><h3 id="转换表的引擎"><a href="#转换表的引擎" class="headerlink" title="转换表的引擎"></a>转换表的引擎</h3><p>1.ALTER TABLE</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE mytable ENGINE = InnoDB;</span><br></pre></td></tr></table></figure><p>该方法需要执行很长时间，在复制期间可能会消耗系统所有的I/O能力，同时原表上会加上读锁。</p><p>2.通过mysqldump工具将数据库文件导出，然后修改文件中CREATE TABLE 中的存储引擎选项，同时注意修改表名。</p><p>3.创建与查询</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE innodb_table like mysiam_table</span><br><span class="line">ALTER TABLE innodb_table engine = InnoDB</span><br><span class="line">INSERT INTO innodb_table select * from myisam_table</span><br></pre></td></tr></table></figure><p>如果数据量过大的话，则可以考虑做分批处理，针对每一段数据执行事务提交数据操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">STARAT TRANSACTION;</span><br><span class="line">INSERT INIO innodb_table select * from mysiam_table WHERE id BETWEEN x and y;</span><br><span class="line">COMMIT;</span><br></pre></td></tr></table></figure><h3 id="选择合适的引擎"><a href="#选择合适的引擎" class="headerlink" title="选择合适的引擎"></a>选择合适的引擎</h3><ul><li><p>“除非需要用到某些InnoDB 不具备的特性，并且没有其他办法可以替代，否则都应该InnoDB引擎”。</p></li><li><p>如果要使用全文索引，优先考虑InnoDB加上Sphinx组合，而不是使用支持全文索引的MyISAM。</p></li><li><p>如果不是万不得已，否则建议不要混合使用存储引擎。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;高性能MySQL&quot;&gt;&lt;a href=&quot;#高性能MySQL&quot; class=&quot;headerlink&quot; title=&quot;高性能MySQL&quot;&gt;&lt;/a&gt;高性能MySQL&lt;/h2&gt;&lt;h3 id=&quot;逻辑架构&quot;&gt;&lt;a href=&quot;#逻辑架构&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
    
      <category term="mysql" scheme="http://solamish.github.io/categories/mysql/"/>
    
    
      <category term="后端" scheme="http://solamish.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="mysql" scheme="http://solamish.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Channel</title>
    <link href="http://solamish.github.io/2019/11/02/Channel/"/>
    <id>http://solamish.github.io/2019/11/02/Channel/</id>
    <published>2019-11-02T15:10:38.000Z</published>
    <updated>2019-11-02T15:15:23.593Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><h3 id="Channel的基本语法"><a href="#Channel的基本语法" class="headerlink" title="Channel的基本语法"></a>Channel的基本语法</h3><p>如果说goroutine是Go语言程序的并发体的话，那么channels则是它们之间的通信机制。使用channel，我们可以在两个goroutine之间通信（传输数据）。</p><p>使用内置的make函数，我们可以创建一个channel：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>) <span class="comment">// ch的数据类型是chan int</span></span><br></pre></td></tr></table></figure><p>一个channel有发送和接受两个主要操作。发送和接收两个操作都使用<code>&lt;-</code>运算符。在发送语句中，<code>&lt;-</code>运算符分割channel和要发送的值。在接收语句中，<code>&lt;-</code>运算符写在channel对象之前。一个不使用接收结果的接收操作也是合法的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ch &lt;- x  <span class="comment">// 将变量x发送给管道ch</span></span><br><span class="line">x = &lt;-ch <span class="comment">// 变量x接受管道ch发送过来的值</span></span><br><span class="line">&lt;-ch     <span class="comment">// 接受管道ch发送过来的值，但不使用</span></span><br></pre></td></tr></table></figure><h4 id="不带缓存的channel"><a href="#不带缓存的channel" class="headerlink" title="不带缓存的channel"></a>不带缓存的channel</h4><p>一个基于无缓存Channels的发送操作将导致发送者goroutine阻塞，直到另一个goroutine在相同的Channels上执行接收操作，当发送的值通过Channels成功传输之后，两个goroutine可以继续执行后面的语句。反之，如果接收操作先发生，那么接收者goroutine也将阻塞，直到有另一个goroutine在相同的Channels上执行发送操作。</p><p>不带缓存的channel的声明方式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch = <span class="built_in">make</span>(<span class="keyword">chan</span> T) <span class="comment">//可以接收和发送类型为 T 的数据</span></span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ch <span class="keyword">chan</span> T  <span class="comment">// 可以接收和发送类型为 T 的数据</span></span><br></pre></td></tr></table></figure><p>我们来看一个栗子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> channel = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">var</span> send = <span class="number">6666</span></span><br><span class="line">    <span class="comment">// 关键字go后跟的是需要被并发执行的代码块，它由一个匿名函数代表</span></span><br><span class="line">    <span class="comment">// 在这里，我们只要知道在花括号中的就是将要被并发执行的代码就可以</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">channel &lt;- send</span><br><span class="line">fmt.Println(<span class="string">"数据已发送"</span>)</span><br><span class="line">&#125;()</span><br><span class="line">    <span class="comment">// 这里让主线程休眠1秒钟</span></span><br><span class="line">    <span class="comment">// 以使上面的goroutine有机会被执行</span></span><br><span class="line">    time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行上述代码后，我们发现控制台并没有输出“数据已发送”这几个字样。这是因为我们只向channel传递了sent的值，而没有从channel中取出，从而导致当前goroutine被阻塞，也就是Println这条语句没有被执行。</p><p>为此我们稍作改进:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> channel = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">var</span> send = <span class="number">6666</span></span><br><span class="line"><span class="keyword">var</span> receive <span class="keyword">int</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 向channel中传递sent的值</span></span><br><span class="line">channel &lt;- send</span><br><span class="line">fmt.Println(<span class="string">"数据已发送"</span>)</span><br><span class="line">&#125;()</span><br><span class="line">    <span class="comment">// 使用receive接受从channel中传来的值</span></span><br><span class="line">receive = &lt;- channel</span><br><span class="line">fmt.Println(receive)</span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">数据已发送</span><br><span class="line"><span class="number">6666</span></span><br></pre></td></tr></table></figure><p>我们成功地接受到了channel中的值，并解决了goroutine的阻塞问题。（只有channel的接收者，也会导致当前goroutine的阻塞，感兴趣的同学可以自己模拟实现下）</p><h3 id="带缓存的Channel"><a href="#带缓存的Channel" class="headerlink" title="带缓存的Channel"></a>带缓存的Channel</h3><p>带缓存的Channel内部持有一个元素队列。队列的最大容量是在调用make函数创建channel时通过第二个参数指定的。下面的语句创建了一个可以持有三个字符串元素的带缓存Channel。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>我们可以在无阻塞的情况下连续向新创建的channel发送三个值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ch &lt;- <span class="string">"A"</span></span><br><span class="line">ch &lt;- <span class="string">"B"</span></span><br><span class="line">ch &lt;- <span class="string">"C"</span></span><br></pre></td></tr></table></figure><p>但当我们发送第四个数据的时候，就会造成当前goroutine的阻塞</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 声明了一个带有3个缓存空间的channel</span></span><br><span class="line"><span class="keyword">var</span> channel = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">channel &lt;- <span class="string">"A"</span></span><br><span class="line">channel &lt;- <span class="string">"B"</span></span><br><span class="line">channel &lt;- <span class="string">"C"</span></span><br><span class="line">fmt.Println(<span class="string">"我发送了3个数据"</span>)</span><br><span class="line">        <span class="comment">// 当发送第四个值的时候，goroutine阻塞</span></span><br><span class="line">channel &lt;- <span class="string">"D"</span></span><br><span class="line">fmt.Println(<span class="string">"我发送了第4个数据"</span>)</span><br><span class="line">&#125;()</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我发送了3个数据</span><br></pre></td></tr></table></figure><h3 id="Range-amp-Close"><a href="#Range-amp-Close" class="headerlink" title="Range&amp;Close"></a>Range&amp;Close</h3><p><code>for value:=range ch</code>操作可以说是非常熟悉了，当我们遍历slice或者map时也是同样的用法</p><p><code>close</code>也就是golang的内置函数，可以用于关闭一个channel</p><p>对一个已经被close过的channel进行接收操作依然可以接受到之前已经成功发送的数据</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(n <span class="keyword">int</span>, c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">x, y := <span class="number">1</span>, <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">c &lt;- x</span><br><span class="line">x, y = y, x + y <span class="comment">//交换变量的便利写法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(c) <span class="comment">//关闭通道</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">go</span> fibonacci(<span class="built_in">cap</span>(c), c) <span class="comment">//cap(c)即为c的容量大小</span></span><br><span class="line">    <span class="comment">// 不断读取channel数据，直到channel被显式关闭</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> c &#123; </span><br><span class="line">fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>记住应该在生产者的地方关闭channel，而不是消费的地方去关闭它，这样容易引起panic。</p><p>另外，关闭一个已经被关闭的channel也将导致panic。</p><h3 id="单方向的Channel"><a href="#单方向的Channel" class="headerlink" title="单方向的Channel"></a>单方向的Channel</h3><p>前面我们提到，channel具有接受和发送两种操作，但如果我们只想要一个具有发送功能的channel应该怎么办呢？</p><p>Go语言的类型系统提供了单方向的channel类型，分别用于只发送或只接收的channel。</p><p>类型<code>chan&lt;- int</code>表示一个只发送int的channel，只能发送不能接收。相反，类型<code>&lt;-chan int</code>表示一个只接收int的channel，只能接收不能发送。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">send := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">go</span> counter(send)</span><br><span class="line">squarer(send)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">counter</span><span class="params">(out <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> x := <span class="number">0</span>; x &lt; <span class="number">100</span>; x++ &#123;</span><br><span class="line">out &lt;- x</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(out)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">squarer</span><span class="params">(in &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> v := <span class="keyword">range</span> in &#123;</span><br><span class="line">fmt.Println(v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通道死锁"><a href="#通道死锁" class="headerlink" title="通道死锁"></a>通道死锁</h3><p>通道两段互相阻塞对方，会形成死锁状态。Go运行时会检查并panic，停止程序。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">out := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">out &lt;- <span class="number">2</span></span><br><span class="line"><span class="keyword">go</span> f1(out)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f1</span><span class="params">(in <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(&lt;-in)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fatal error: all goroutines are asleep - deadlock!</span><br></pre></td></tr></table></figure><p>显然在<code>out &lt;- 2</code>的时候，由于没有接受者，主线程被阻塞。</p><h2 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h2><p><code>select</code> 是一种与 <code>switch</code> 非常相似的控制结构，与 <code>switch</code> 不同的是，<code>select</code> 中虽然也有多个 <code>case</code>，但是这些 <code>case</code> 中的表达式都必须与 Channel的操作有关，也就是 Channel 的读写操作，下面的函数就展示了一个包含从 Channel 中读取数据和向 Channel 发送数据的 <code>select</code> 结构：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(ch, quit <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">x, y := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> ch &lt;- x:</span><br><span class="line">x, y = y, x+y</span><br><span class="line"><span class="keyword">case</span> &lt;-quit:</span><br><span class="line">fmt.Println(<span class="string">"quit"</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span> )</span><br><span class="line">quit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span> ; i++ &#123;</span><br><span class="line"><span class="comment">// 接受通道c传来的值，并打印到控制台</span></span><br><span class="line">fmt.Println(&lt;-c)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当协程执行完上述操作后，向quit发送数据</span></span><br><span class="line">quit &lt;- <span class="number">0</span></span><br><span class="line">&#125;()</span><br><span class="line">fibonacci(c, quit)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这里，我们可能会疑惑，如果同时有多个case需要处理，那怎么办？</p><p>如果多个case同时就绪时，select会随机地选择一个执行，这样来保证每一个channel都有平等的被select的机会</p><p>如果没有case需要处理，则会选择<code>default</code>去处理，若没有<code>default</code>语句时则<code>select</code>语句会被阻塞（<code>select</code>默认为阻塞），直到某个case需要处理</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Channel&quot;&gt;&lt;a href=&quot;#Channel&quot; class=&quot;headerlink&quot; title=&quot;Channel&quot;&gt;&lt;/a&gt;Channel&lt;/h2&gt;&lt;h3 id=&quot;Channel的基本语法&quot;&gt;&lt;a href=&quot;#Channel的基本语法&quot; class=&quot;
      
    
    </summary>
    
    
      <category term="golang基础语法" scheme="http://solamish.github.io/categories/golang%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    
    
      <category term="后端" scheme="http://solamish.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Golang" scheme="http://solamish.github.io/tags/Golang/"/>
    
  </entry>
  
</feed>
